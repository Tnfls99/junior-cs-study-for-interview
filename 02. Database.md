
<details>
    <summary><b>관계형 데이터베이스</b></summary> 

## 정리
### 관계형 데이터베이스란?
- 데이터를 테이블에 저장하는 데이터베이스
- 데이터 구조가 명확하고, 변경될 여지가 없을 경우에 사용하면 좋다.
- Scale-up 만 가능하다.
#### 장점
- 데이터 분류, 정렬, 탐색 속도가 빠름
- 데이터의 무결성과 신뢰성 보장
- 정규화에 따른 갱신 비용이 적음
#### 단점
- 기존 작성된 스키마 수정이 어려움
- 데이터 베이스의 부하를 분석하기 어려움
- 빅데이터 처리시 비효율적
### 용어
- 열: 테이블에서 각각의 열은 유일한 이름을 가지고 있으며, 자신만의 타입으로 가지고 있다. 필드 또는 속성으로도 불린다.
- 행: 관계된 데이터의 묶음. 튜플 또는 레코드라고도 불린다.
- 값: 테이블에는 각각의 행과 열에 대응하는 값을 가진다.
- 키: 테이블에서 행의 식별자로 이용되는 열
- 관계: 테이블과 테이블과의 관계를 수에 따라 나타낸 것
  - 일대일 관계
  - 일대다 관계
  - 다대다 관계
- 스키마: 테이블을 설계하기 위한 메타데이터
### 파일시스템과 DBMS
#### 파일시스템
- 파일을 저장장치에 저장하고 사용하기 위한 규칙
- 구성요소는 순차적인 레코드들이며, 레코드는 파일을 다룰 때의 데이터 단위이다.
- 단점:
  - 데이터 종속성: data 가 변경될 때마다 프로그램 수정 필요
  - 데이터 중복성 & 비일관성: 중복된 데이터의 수정 시, 불일치 발생 가능
  - 데이터 접근이 어렵다.
  - 데이터 무결성: 데이터에 대한 제약 조건을 추가하기 어렵다.
  - 원자성 문제
  - 다중 사용자로에의한 동시 접근 안됨
  - 보안 문제: 세밀한 권한 설정이 어렵다.
## 예상 질문
- 관계형 데이터베이스에 대해 설명해주세요
- 장단점에 대해 설명해주세요
- RDBMS와 파일 시스템의 차이에 대해 설명해주세요
- RDB 의 크기를 확장하려면 어떻게 해야할까요?
## 참조
- https://velog.io/@csy9604/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%B9%84%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4
</details> 

<details>
    <summary><b>Key의 종류</b></summary> 

## 정리
### 키의 속성
- 유일성: 하나의 키 값으로 튜플을 유일하게 식별할 수 있는 성질
- 최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질
### 슈퍼키
- 테이블에서 각 행을 유일하게 식별할 수 있는 속성들의 집합
- 유일성 O, 최소성 X
### 후보키
- 튜플들을 유일하게 식별하기 위해 사용되는 속성들의 부분집합
- 슈퍼키중 최소성을 만족하는 집합을 의미한다.
- 유일성 O, 최소성 O
- 모든 릴레이션은 하나 이상의 후보키를 가져야 한다.
### 기본키
- 후보키 중 선택된 속성
- 유일성 O, 최소성 O
- 중복된 값과 NULL 값이 허용되지 않는다.
- 자주 변경되는 값은 기본키로 적절하지 않다.
### 외래키
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
- 참조 테이블의 기본키에 없는 값은 외래키의 값으로 입력할 수 없다.
### 대체키
- 후보키에서 기본키를 제외한 나머지

## 예상 질문
- 키의 종류에 대해 간단하게 설명해주세요.
- 기본키와 대체키, 후보키에 대해 비교해주세요.
- 외래키의 제약에 대해 설명해주세요.
- 외래키에 NULL 값이 들어갈 수 있을까요?
- 기본키는 수정할 수 있을까요?
  - 변경될 수는 있지만 기본키가 변경됨으로써 기본키를 제외하고 나머지 속성이 같았던 튜플이 기본키를 바꿈으로써 중복이 될 수 있기 때문에 주의해야 합니다.
- PK 를 대체키로 사용하면 얻는 이점은 무엇이 있을까요?
  - 변경 가능성 제거
  - 성능 향상
  - 데이블 구조 간결
  - 데이터 무결성 보장
## 참조
- https://hyejin.tistory.com/m/118
- https://mangkyu.tistory.com/21
- https://mangkyu.tistory.com/287
</details> 

---

<details>
    <summary><b>인덱스 개념, 필요성</b></summary> 

## 정리
### 인덱스란?
- DBMS 에서 데이터의 조작 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능
- 키 값을 중심으로 정렬되어 있다.
### 장단점
- 장점
  - 검색 속도 향상
- 단점
  - 인덱스를 관리하기 위한 추가 공간 및 작업 필요
### Inno DB (B-Tree) 에서의 인덱스
- 기본적으로 B-Tree 자료구조 사용
- PK 를 Clustered Index 로 사용
  - 만약 PK 를 지정하지 않으면, NOT NULL 인 UNIQUE 키를 Clustered Index 로 사용. 만약 이것도 없다면 hidden clustered index 를 생성.
  - PK 기반의 검색은 빠르나, 레코드의 저장이나 PK 값의 변경은 상대적으로 느림
#### Inno DB 의 Secondary Index 에 실제 레코드 주소가 들어가지 않는 이유는?
- 만약 실제 레코드 주소가 들어간다면, Clustered Index 의 키 값이 변경될 때마다 Secondary Index 에 있는 레코드 주소가 변경되어야 한다. 때문에 Secondary Index 에 실제 레코드 주소를 넣는 것이 아니라 `PK` 값을 저장한다. 
#### Clustered Index vs Non-Clustered Index
- Clustered Index: 인덱스의 정렬 기준과 레코드의 정렬 기준이 같은 형태
  - 장점: PK 로 범위 검색 하는 경우 매우 빠르다.
  - 단점 
    - Secondary Index 가 PK 를 갖고 있기 때문에 PK 가 커질 경우 전체적으로 인덱스의 크기가 커진다.
    - Secondary Index 로 검색할 때 PK 로 다시 한번 검색하기 때문에 처리 성능이 다소 느리다.
    - Secondary Index 가 PK 와 직접적으로 연관되어 있어 레코드를 삽입하거나 PK 를 변경할 때 처리 성능이 다소 느리다.
- Non-Clustered Index: 인덱스의 정렬 기준과 레코드의 정렬 기준이 다른 형태(보통 삽입된 순서로 저장됨)
#### 인덱스 키 관리 및 검색
- 키 추가
  - Inno DB 에서는 B-Tree 를 기반으로 하므로 노드를 새로 추가하는데 비용이 많이 든다.
  - 하지만 Inno DB 에서는 버퍼를 두어서 디스크 I/O 를 최대한 줄이는 방식을 이용한다.
    - INSERT 뿐만 아니라 UPDATE, DELETE 내용도 저장 (Change Buffer)
- 키 삭제
  - 해당 키값이 저장된 B-Tree 의 리프 노드를 찾아 삭제 마크.
  - 공간은 지워지지 않고 그대로 방치하거나 재활용됨
  - 레코드가 삭제될 경우 인덱스 트리에는 그대로 남아있으므로, 최악의 경우 인덱스 노드의 수가 레코드의 수보다 커져 인덱스를 활용하지 않는게 더 빠른 경우가 존재할 수 있다.
- 키 변경
  - 키 삭제 작업 후 삽입 작업 진행
- 키 검색
  - 100% 일치 또는 부등호 비교, 값의 앞부분이 일치하는 경우에 사용 가능
  - 값의 뒷부분이 일치하는 경우 인덱스 사용 불가능
  - 변형된 키 값의 경우 트리의 값들과 비교할 수 없기 때문에 인덱스 사용 불가능

## 예상 질문
- 인덱스에 대해 설명해주세요.
- 클러스터링 인덱스와 세컨더리 인덱스에 대해 설명해주세요.
- 인덱스를 설정한 것이 항상 빠를까요?
## 참조

</details> 

<details>
    <summary><b>인덱스를 어느 column에 사용할까</b></summary> 

## 정리
### 인덱스를 사용하면 좋은 경우
- 규모가 큰 테이블
- INSERT, UPDATE, DELETE 가 자주 발생하지 않는 컬럼
- JOIN 이나 WHERE, ORDER BY 에 자주 사용되는 컬럼
- 데이터 중복도가 낮은 컬럼
### 인덱스 키 선택 시 고려
#### 키 값의 크기
- Inno DB 에서 Disk I/O 를 하는 기본 단위를 Page 또는 Block 이라고 한다.
- Inno DB 에서 이 값은 16KB 로 고정되어 있다.
- Block 구조는 키 값과 자식 노드 주소로 구성된 노드의 집합체이다.
- 평균적으로 자식 노드 주소의 크기는 일정하므로 키 값에 따라 한 Block 에 들어갈 수 있는 노드의 개수가 정해진다.
- 따라서, 키 값이 커질 수록 한 Block 에 들어가는 노드는 적어지고, 같은 수의 노드를 읽어오기 위해 더 많은 Disk I/O 가 발생할 수 있다.
> 결론: 키 값이 커지면 더 많은 Disk I/O 가 발생할 수 있다.
#### 선택도(기수성)
- 선택도(기수성): 인덱스 키 값이 몇 종류로 구성되어 있는지
  - 전체 인덱스 키 값이 100개라고 가정하고, 10종류로 구성되어 있다고 하면 기수성은 10이다.
- 인덱스 키 값은 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 선택도는 올라간다.
- 선택도가 올라가면 검색 대상이 줄기 때문에 그만큼 빠르다.
- 성별같은거 고르면 안된다.
> 결론: 인덱스는 종류가 많은 열을 골라야 한다.
#### 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않는 것보다 비용이 더 든다.
  - 인덱스 파일을 들렸다 하나의 레코드 데이터를 들고 올 때마다 Disk I/O 가 발생하기 때문
  - 반면 한 블록에 최대한 많은 레코드를 가져올 수 있다.
- 따라서 읽어야 하는 레코드 수가 20% 가 넘을 때는 인덱스를 사용하지 않고 직접 테이블을 모두 읽는 것이 효율적이다.
- 이 때는 옵티마이저에 의해 인덱스를 사용하지 않고 읽어온다.
> 결론: 읽어야 하는 레코드가 많으면 인덱스가 불리할 수 있다.
### PK 설정 시 고려해야 할 것
1. PK 는 되도록 검색에 자주 쓰이는 칼럼으로 사용하는 것이 좋다.
2. PK 는 반드시 명시하자
   - PK 가 없을 경우, 내부적으로 칼럼을 추가하는데 개발자가 이 컬럼을 통해 검색 쿼리를 할 수 없으므로 불이익이 크다.
3. 여러 칼럼의 복합으로 PK 를 설정하는 것보다 AUTO-INCREMENT 칼럼을 사용해보자.
   - 이와 같이 PK 의 크기가 크고 Secondary Index 를 사용한다면, 인조 식별자를 사용하는 것을 고려해보자.
### 다중 칼럼 인덱스
![Multi_Column_Index](Multi_Column_Index.png)
- 2개 이상의 컬럼을 포함하는 인덱스
- 다중 컬럼 인덱스에서 앞의 칼럼의 순서에 위의 칼럼의 순서가 영향을 받는다.
- 인덱스 내에서 각 칼럼의 위치가 중요하다.
### Unique Index
- MySQL 에서 Unique 키워드 사용시 자동으로 Index 설정이 된다.
- Null 은 특정 값이 아니므로 2개 이상 저장 가능하다.
  - Not Null 옵션 설정이 중요해보인다.
#### Unique Index vs Other Secondary Index
- 데이터 읽기
  - 읽어야 하는 레코드의 크기가 동일하다면 성능 차이는 거의 없다.
  - 일반적으로 읽어야 하는 레코드의 크기는 Unique 의 경우가 더 적다.
- 데이터 쓰기
  - Unique Index 의 경우 레코드를 추가할 때 중복된 값이 있는지 확인하는 과정이 추가적으로 들어간다.
    - 중복된 값을 확인하는 과정 때문에 버퍼를 이용하지 못한다. 따라서 Disk I/O 가 필수적으로 일어난다.
  - 따라서 Unique Index 가 다른 Secondary Index 에 비해 느리다.
  - MySQL 에서는 중복된 값을 체크할 때 읽기 잠금을 하고 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 때 데드락이 자주 발생한다.
#### 사용 시 주의 사항
- 일반 인덱스와 Unique 를 같은 칼럼에 동시에 걸 필요는 없다. (동일한 역할을 수행하므로)
- 마찬가지로 PK 와 Unique 를 같은 컬럼에 동시에 걸 필요는 없다.
- 유일성이 필요하지 않다면 Unique 를 걸지 말고 일반 인덱스를 걸자
### 외래키
- 외래키 설정시 자동으로 인덱스가 생성된다.
#### Inno DB 외래키 관리
1. 참조되는 테이블(PK)이 쓰기 잠금 중일 때, 참조하는 테이블(FK)는 외래키에 대해 잠금 대기를 한다.
2. 참조되는 테이블이 쓰기 잠금중이어도 참조하는 테이블에서 외래키가 아닌 칼럼에 대해서는 잠금 대기를 하지 않는다.
   - 외래키가 아니면 락 해제를 기다리지 않음
> 외래키는 이처럼 잠금 경합이 발생할 수 있으므로 이를 고려해야 한다.
## 예상 질문
- 인덱스는 어느 경우에 사용하면 좋을까요?
- 왜 다중 컬럼 인덱스에서 인덱스를 설정할 때 칼럼의 순서가 중요할까요?
- Unique 와 Index 를 한 칼럼에 같이 할 경우 어떻게 되나요?
## 참조
- https://jjingho.tistory.com/170
</details> 

<details>
    <summary><b>인덱스의 자료구조</b></summary> 
</details> 

<details>
    <summary><b>인덱스는 왜 hash table이 아니라 b+tre로 구현되었을까</b></summary> 
</details> 

---
