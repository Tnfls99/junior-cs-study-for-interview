<details>
  <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

### 답변

장점으로는 JVM에서 동작하기 때문에 운영체제에 독립적이고 객체지향 언어이기 때문에 이해하기가 쉽습니다. 또한 가비지 컬렉터에 의해 메모리를 자동으로 관리해준다는 점이 있습니다.
단점으로는 JVM 에 의해 번역되는 과정이 필요하기 때문에 비교적 느립니다. 또한 가비지 컬렉터로 인하여 비교적 많은 메모리 공간이 필요합니다.

### 정리

- 장점
    - JVM에서 동작하기 때문에 운영체제에 독립적
    - 객체지향 언어이기 때문에 이해하기 쉽다.
    - 오픈소스로 사용할 수 있고 커뮤니티가 잘 발달되어 있다.
    - 멀티쓰레드를 쉽게 구현할 수 있다.
    - 가비지 컬렉터에 의해 메모리 관리를 자동으로 해준다.
- 단점
    - 컴파일되고 번역하는 과정을 거치기 때문에 비교적 느리다.
    - 가비지 컬렉터로 인해 메모리 공간 필요

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90
- https://data-flair.training/blogs/pros-and-cons-of-java/

</details>

---

<details>
  <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

### 답변

자바의 데이터 타입은 기본 데이터 타입과 참조 타입으로 나뉩니다. 기본 데이터 타입으로는 byte, short, int, long, float, double, boolean, char 가 있으며 Stack 영역에
저장됩니다. 참조 타입은 기본형은 제외한 모든 타입이며, Heap 영역에 저장됩니다.

### 정리

- 기본 데이터 타입(Primitive Data Type)
    - 정수형 : byte, short, int, long
    - 실수형 : float, double
    - 논리형 : boolean(ture/false)
    - 문자형 : char
    - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.
- 참조 타입(Reference Data Type)
    - 참조 타입 종류: class, array, interface, Enumeration
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용하여 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이다.
    - String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
    - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
    - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
    - 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85

</details>

<details>
  <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

### 답변

Wrapper 클래스는 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스입니다. 기본 타입의 데이터를 Wrapper 클래스의 값으로 변환하면 Boxing,
반대의 경우를 Unboxing이라고 합니다.

### 정리

- Wrapper Class
    - 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스
    - java.lang 패키지에 존재

| 기본 타입     | 래퍼 클래스      |
|-----------|-------------|
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

- Boxing
    - 기본 타입의 데이터를 Wapper 클래스의 인스턴스로 변환하는 과정
- Unboxing
    - Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 꺼내는 과정

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#wrapper-class

</details>

---

<details>
  <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary> 

### 답변

자바는 Call by Value 를 따릅니다. 기본 자료형의 경우 해당 값이 복사되어 전달되고, 참조 자료형의 경우 힙 메모리의 참조값이 복사되어 전달됩니다.

### 정리

- 자바에서 파라미터는 항상 `값`으로 전달됩니다. (파라미터의 복사본이 메서드에 전달)
- 기본 자료형의 경우 값의 복사본이 전달됩니다.
- 참조 자료형의 경우 힙 메모리의 주소값이 복사되어 전달됩니다.
    - 아래 예시의 경우 User 의 메모리가 복사되어 전달된다. b 의 경우 새로운 주소를 할당하는데 메서드가 종료되면 원본 b 에는 반영되지 않는다.
  ```java
  class User {
      public int age;
  
      public User(int age) {
          this.age = age;
      }
  }
  
  public class ReferenceTypeTest {
  
      void test() {
          User a = new User(10);
          User b = new User(20);
  			  
          System.out.println(a); // age: 10
          System.out.println(b); // age: 20
          modify(a, b);
  
          System.out.println(a); // age: 11 
          System.out.println(b); // age: 20
      }
  
      private void modify(User a, User b) {
          a.age++;
  
          b = new User(30);
          b.age++;
      }
  }
  ```

### 참고 링크

- https://bcp0109.tistory.com/360
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#call-by-reference%EC%99%80-call-by-value%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

### 답변

자바의 접근 제어자로는 제약 없이 접근 가능한 public, 동일 패키지 또는 상속 관계에서 접근 가능한 protected, 동일 패키지에서만 접근 가능한 package-private, 선언한 객체에서만 사용 가능한
private 이 있습니다.

### 정리

| 접근 제어자	           | 설명                             |
|-------------------|--------------------------------|
| `public`          | `해당 객체를 사용하는 프로그램 어디에서나 접근 가능` |
| `protect`         | `동일 패키지 또는 상속 관계의 객체에서 접근 가능`  |
| `package-private` | `동일 패키지에서 접근 가능`               |
| `private`         | `해당 객체에서만 사용 가능`               |

### 참고 링크

- http://www.tcpschool.com/java/java_modifier_accessModifier
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95

</details>

---

<details>
  <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

### 답변

클래스는 객체를 만들어 내기 위한 틀로서 객체가 가질 수 있는 속성과 메서드를 정의하며, 이를 실체화한 것이 객체입니다. 인스턴스는 객체의 구체적인 사례입니다.

### 정리

- 클래스(Class)
    - 객체를 만들어 내기 위한 설계도 혹은 틀
    - 연관되어 있는 변수와 메서드의 집합
- 객체(Object)
    - 소프트웨어 세계에 구현할 대상
    - 클래스에 선언된 모양 그대로 생성된 실체
    - '클래스의 인스턴스(instance)' 라고도 부른다.
- 인스턴스(Instance)
    - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
        - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
        - 실체화된 인스턴스는 메모리에 할당된다.

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

### 답변

클래스 멤버를 정의할 때 사용되며, 객체가 생성되기 전에 초기화 되며, 모든 인스턴스에서 공유되어 사용됩니다.

### 정리

- 클래스 멤버를 정의할 때 사용
- 객체가 생성되기 전에 클래스의 로딩 과정에서 메모리에 할당되므로, 객체 생성 없이 클래스 이름만으로 접근할 수 있다.
- static 키워드를 적절히 사용하면, 메모리를 효율적으로 사용하거나 객체 생성 없이도 편리하게 접근할 수 있는 장점이 있다.

<details> <summary>클래스 멤버와 인스턴스 멤버</summary>
- 클래스 멤버: 클래스에 존재하는 변수와 메서드.
- 인스턴스 멤버: 객체(인스턴스)에 존재하는 변수와 메서드. static 키워드를 사용하지 않고 정의한다.
- 클래스 멤버에서는 인스턴스 멤버가 접근 가능하지만, 인스턴스 멤버에서는 클래스 멤버로 접근이 불가능하다.
  ![](../../../../../var/folders/1q/jkln67w958d9zskbyx2v6p940000gn/T/TemporaryItems/NSIRD_screencaptureui_x5cM7o/스크린샷 2023-03-31 오전 3.08.16.png)
</details>

### 참고 링크

- [클래스 멤버와 인스턴스 멤버](https://hyuntaekhong.github.io/blog/java-basic12/)

</details>

<details>
  <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary> 

### 답변

- static 멤버는 클래스가 로딩될 때 메모리에 할당되며, 모든 인스턴스에서 공유됩니다. 반면에 non-static 멤버는 각 인스턴스가 생성될 때 메모리에 할당되고, 인스턴스마다 고유한 값을 가집니다.

### 정리

- 다음과 3가지의 차이점이 존재한다.

| 항목           | 메모리 할당 시기   | 접근 방법                     | 공유 여부             |
|--------------|-------------|---------------------------|-------------------|
| `static`     | 클래스가 로딩될 때  | 인스턴스를 생성하지 않고 클래스 이름으로 접근 | 모든 인스턴스가 동일한 값 공유 |
| `non-static` | 인스턴스가 생성될 때 | 인스턴스를 생성한 후 접근            | 인스턴스마다 고유한 값 존재   |

### 참고 링크

</details>

<details>
  <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

### 답변

- main 메서드는 프로그램이 실행될 때 가장 먼저 호출됩니다. 인스턴스가 생성되기 전에 호출되어야 하기 때문에 static으로 정의되어야 합니다.

### 정리

- main 메서드는 프로그램이 시작할 때 JVM에 의해 호출됩니다. 만약 non-static 메서드라면, main 메서드를 호출하기위해 클래스를 인스턴스화 시켜야 하기 때문에 JVM 에서 직접 호출이 불가능합니다.
  따라서 main 메서드는 static 메서드여야 합니다.

### 참고 링크

- https://www.scaler.com/topics/why-main-method-is-static-in-java/

</details>

<details>
  <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

### 답변

- static 이 붙은 변수는 해당 클래스가 로딩될 때 Method Area에 한번 초기화되고 값 변경이 일어나지 않습니다. 이후에 인스턴스를 초기화하지 않고 사용할 수 있습니다.

### 정리

- 자바 프로그램이 실행되고 JVM이 프로그램에서 사용되는 클래스를 로드하고, 해당 static 변수를 초기화합니다.
- JVM은 Method Area 에 static 변수에 메모리를 할당합니다.

### 참고 링크

</details>

---

<details>
  <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

### 답변

- 오버로딩은 메서드의 이름은 같고 파라미터를 다르게 한 것이고, 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 의미합니다.

### 정리

- 오버로딩
    - 이름은 같고 매개변수의 수, 타입 또는 순서가 다른 여러 메서드 정의
    - 반환하는 타입은 달라도 된다.
- 오버라이딩
    - 메서드 이름과 매개변수가 동일한 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것
    - 오버라이딩된 메서드가 자식클래스의 인스턴스에서 호출되면 부모 클래스의 메서드는 무시된다.

### 참고 링크

- https://hyoje420.tistory.com/14

</details>

---

<details>
  <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

### 답변

- 둘의 차이는 목적에 있어 차이가 있습니다. 추상클래스는 abstract 키워드로 선언된 클래스로서 기능을 이용하고 확장하도록 의도합니다. 반면, 인터페이스는 추상메서드로만 이루어진 것으로 기능의 구현을 강제하도록 의도합니다. 이때문에 추상클래스는 공통 기능을 가지는 기반 클래스로 적합하며, 인터페이스는 다형성이 필요한 경우에 적합합니다. 
### 정리

#### 추상클래스
- abstract 키워드로 선언된 클래스
- 자식 클래스가 추상클래스의 기능을 이용하고 확장하는데 초점을 둔다.
- 클래스이기 때문에 다중상속은 지원하지 않는다.
- 기능의 확장에 초점을 두기 때문에 공통 기능을 가지는 베이스 클래스에 적합하다.
#### 인터페이스
- 추상 메서드와 상수로만 이루어진 것
- 인터페이스는 선언된 기능을 구현하도록 강제한다.
- 기능의 구현을 강제하기 때문에 같은 기능을 다르게 구현하는 다형성이 필요한 경우에 적합하다.
- 다중 상속이 가능하다.
  - 다중 상속을 할 때 메서드 충돌은 어떻게 해결할까?
    - 다중 상속을 하더라도 인터페이스에는 구현부가 없고, 구현 부분이 하나이기 때문에 컴파일 에러는 나타나지 않는다.
    - 다만, default 메서드를 통해 인터페이스에서 구현하는 경우 컴파일러는 오류를 내보낸다. (모두 구현된 경우)
    - 이 경우 2가지 해결 방법이 존재한다.
      1. 인터페이스에서 구현하지 않고 상속한 클래스에서 구현한다.
      2. 하나의 인터페이스로 구현을 위임한다.
#### 추상 메서드
- abstract 키워드와 함께 구현부는 작성되지 않고 선언부만 작성된 메서드
- final 키워드가 붙은 메서드는 추상 메서드로 만들 수 없다.
- 물론 static 메서드도 추상 메서드로 만들 수 없다.
### 참고 링크

- https://brunch.co.kr/@kd4/6
- [static 메서드가 추상메서드 될 수 없는 이유](https://stackoverflow.com/questions/370962/why-cant-static-methods-be-abstract-in-java)
- [다중상속 시 메서드 충동 해결](https://webfirewood.tistory.com/130)
</details>

<details>
    <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary> 

### 답변

- 다중 상속을 허용하지 않는 이유는 모호성때문입니다. 다중 상속하는 클래스에서 이름이 같은 메서드가 있다면 어떤 메서드를 컴파일러가 호출할지 모호하기 때문에 자바에서는 다중 상속을 지원하지 않습니다.
### 정리

- 자바에서는 모호성때문에 다중 상속을 지원하지 않는다.
- 부모 클래스들에서 같은 이름을 가진 메서드나 변수가 있다면, 자식 클래스에서 어떤 메서드를 컴파일러가 호출할지 모호하기 때문이다.  
### 참고 링크

- https://siyoon210.tistory.com/125
</details>

---

<details>
  <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary> 

### 답변

- 자바의 Error 와 Exception 은 모두 Throwable 객체를 상속받습니다. Error 는 주로 시스템 레벨의 심각한 에러로서 개발자가 처리할 수 없는 에러입니다. 반면, Exception 은 크게 RuntimeException 과 다른 Exception 으로 구분되며, 주로 개발자가 작성한 프로그램에서 발생하는 에러입니다. 
### 정리

#### Error
- 시스템에 발생하는 심각한 예외 상황을 나타냄
- OutOfMemoryError, StackOverflowError 등
- 시스템 자체에서 발생하여 개발자가 대응할 수 없다. -> 따로 처리하지 않아도 된다.
#### Exception 
- 개발자가 작성한 프로그램에서 발생하는 예외 상황을 나타냄
- RuntimeException, IOException 등
- 일반적으로 RuntimeException 과 나머지 Exception 으로 구분되어 구조화한다.
- try-catch-finally 구문을 사용하여 예외 처리를 해야한다.
### 참고 링크

</details>

<details>
  <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

### 답변

- UncheckedException 와 CheckedException 의 차이는 예외 처리의 강제성에 있습니다. CheckedException 은 컴파일 과정에서 발생하여 예외를 강제하는 반면, UncheckedException 은 런타입 과정에서 발생하는 예외이기 때문에 컴파일 과정에서 예외 처리를 강제하지 않습니다. 
### 정리

#### UncheckedException

- RuntimeException 과 이를 상속한 예외
- 런타임 과정에서 발생하는 예외
- 예외 처리를 강제받지 않음
  - 다만 예외가 런타임 과정에서 발생하기 때문에 예상하지 못한 에러가 발생할 수 있다.
  - 따라서 예외 상황이 발생할 것을 대비하여 예외 처리를 하는 것이 좋다.
#### CheckedException

- RuntimeException 을 제외한 Exception 예외
- 컴파일 과정에서 발생하는 예외
- 컴파일러에 의해 예외 처리가 강제됨
### 참고 링크

</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary> 

### 답변

- 예외 처리 방법으로 예외 상황을 정상 상태로 돌려놓는 예외 복구, 호출한 메서드로 예외 처리를 넘기는 예외 회피, 다른 예외로 전환하는 예외 전환이 있습니다.
### 정리

#### 예외 복구
- 예외가 발생하더라도 애플리케이션이 정상적인 흐름으로 동작하도록 진행
#### 예외 회피
- 예외가 발생하면 throws 를 통해 호출한 메서드로 예외 처리를 위임하는 것
#### 예외 전환
- 다른 예외로 전환.
- 호출한 메서드에서 예외를 처리할 때 더 명확하게 예외 상황을 인지할 수 있도록 돕는다.
- throw 를 통해 실행
### 참고 링크

- https://www.nextree.co.kr/p3239/
</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary>

### 답변

- final 키워드는 변수와 메서드, 클래스에 붙어 변하지 않도록 하는 역할을 수행합니다. 의도치 않은 변경을 줄여 코드 안정성을 보장하고 final 변수는 상수이기 때문에 컴파일 과정에서 성능 향상을 가져올 수 있습니다. 또한, 코드 가독성을 높일 수 있습니다.
### 정리

#### 코드 안정성
- 의도치 않은 코드 변경을 줄일 수 있기 때문에 코드 안정성이 높아진다.
#### 성능 향상
- final 변수는 상수로 취급하여 컴파일 과정에서 변수를 계산하는 과정이 준다. 이만큼 성능 향상을 불러올 수 있다.
#### 코드 가독성
- 변수, 메서드, 클래스에 final 키워드를 붙이면 변경되지 않는다는 의미를 명확하게 전달할 수 있다.
### 참고 링크
</details>

<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary> 

### 답변

- final 키워드는 변수, 메서드, 클래스를 변경 불가능하도록 만드는 것이고, finally 는 try-catch 구문 마지막에 항상 실행될 코드 블록을 정의하기 위해 사용됩니다. 마지막으로 finalize 는 GC 가 더이상의 참조가 존재하지 않는 객체를 메모리에서 삭제할 때 사용되는 메서드입니다.
### 정리

#### final
- 기본 데이터 타입에 적용: 변수에 저장된 값의 변경이 불가능
- 참조 데이터 타입에 적용: 참조 변수의 힙 메모리를 재할당 불가능
- 메서드에 적용: 오버라이드 불가능
- 클래스에 적용: 상속 불가능
#### finally
- try-catch 구문이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용
- JVM 이 종료되거나 해당 프로세스가 종료되지 않는 이상 무조건 실행된다.
  - return 문이 try 에 있어도 finally 코드 블록이 실행됨
  - try-with-resources 구문을 사용할 수 있으면 try-catch-finally 대신 사용할 것
    - 예외가 중복될 경우 디버깅이 힘듦
    - 가독성이 나빠짐
#### finalize
- Garbage Collector 가 더이상 참조가 존재하지 않는 객체를 메모리에서 삭제할 때 호출하는 메서드
- Object 클래스의 finalize 메서드를 오버라이딩하여 커스텀할 수 있다.
### 참고 링크

- https://wjheo.tistory.com/entry/final-finally-finalize-%EC%B0%A8%EC%9D%B4%EC%A0%90
- https://ckddn9496.tistory.com/62
</details>


<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary> 

### 답변

- final 키워드가 붙은 변수는 상수와 같이 취급이 됩니다. 메서드는 오버라이딩이 안되기 때문에 오버라이딩한 메서드를 찾는 과정이 생략됩니다. 클래스는 상속이 불가능하기 때문에 자식 클래스를 찾는 과정이 생략됩니다.
### 참고 링크

</details>


---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary> 

### 답변

- 제네릭은 클래스 내부에서 사용하는 타입을 외부에서 지정할 수 있는 방법입니다. 장점으로는 컴파일 시점에 타입 체크를 진행해 타입 안정성을 보장하고 코드 중복을 줄여줍니다. 반면 단점으로는  문법이 생소하여 가독성이 떨어지고 공변성 때문에 배열과의 호환성이 좋지 않습니다.
### 정리

- 클래스 내부에서 사용하는 타입을 외부에서 지정하는 방법
- 장점
  - 컴파일 시점에 타입 체크를 통해 타입 안정성을 보장
  - 코드 중복을 줄여줌
- 단점
  - 문법이 생소하여 가독성이 떨어짐.
  - 배열의 공변성으로 인해 배열과의 호환성이 떨어짐

#### 무변성(invariant)/무공변
- 하위 타입을 상위 타입의 제네릭에 대입하면 컴파일 에러가 발생한다.
```java
public class Tiger extends Animal {}
```

```java
public class Cage<T> {
	private List<T> animals = ...;
	public void push(T animal) {
		this.animals.add(animal);
    }
	public List<T> getAll() {
		return animals;
    }
}
```

```java
Animal a = new Tiger(); // OK
Cage<Animal> ca = new Cage<Tiger>(); // Compile Error.
```

<br>

- 컴파일 에러가 발생하는 이유를 예를 들어 설명하면
```java
public class Tiger extends Animal {}
public class Lion extends Animal {}
```
```java
Cage<Tiger> ct = new Cage<Tiger>();
Cage<Animal> ca = ct; // 만약 가능하다면

ca.push(new Lion()); // Lion 은 Animal 의 하위 타입이므로 가능

List<Tiger> tigers = ct.getAll(); // 우항의 결과물은 List<Lion> 
```

<br>

- 무공변일 때 문제점
```java
public class Carnivore extends Animal {}
public class Tiger extends Carnivore {}
public class Lion extends Carnivore {}
```
```java
public class Zookeeper {
	public void giveMeat(Cage<Carnivore> cage, Meat m) {
		
    }
}
```
```java
Zookeeper zk = new Zookeeper();
Cage<Tiger> ct = new Cage<>();
zk.giveMeat(ct,m); // Compile Error
```
- 위의 코드를 보면 Cage<Carnivore> 은 Cage<Tiger> 의 상위 타입이 아니기 때문에 에러가 발생한다.
- 공변으로 해결이 가능!

#### 공변(variant)

- 타입 A 가 타입 B 의 상위 타입이고, `T<A>` 가 `T<B>` 의 상위 타입일 때 공변이라고 한다.
- extends 를 이용하여 나타냄
```java
public class Zookeeper {
	public void giveMeat(Cage<? extends Carnivore> cage, Meat m) {
		
    }
}
```
```java
Zookeeper zk = new Zookeeper();
Cage<Tiger> ct = new Cage<>();
zk.giveMeat(ct,m); // 할당 가능

Cage<Lion> cl = new Cage<>();
zk.giveMeat(cl,m); // 할당 가능
```

<br>

- 공변에서의 문제점
  - 공변에서 제네릭 타입을 사용하면 메서드에 값 전달이 되지 않는다.
```java
Cage<Tiger> ct = new Cage<>();

Cage<? extends Carnivore> cage = ct; // OK
cage.push(new Tiger()); // Compile Error
```
- 위의 경우 cage 의 실제 타입이 `Cage<Tiger>` 인지 `Cage<Lion>` 인지 알수 없기 때문에 컴파일 에러 발생
- 반공변으로 해결!

#### 반공변(contravariant)
- A 가 B 의 상위 타입이고, `T<A>` 가 `T<B>` 의 하위 타입이면 반공변
  - super 을 사용하여 나타냄
```java
Cage<Tiger> ct = new Cage<>();

Cage<? super Tiger> ctt = ct; // OK
ctt.push(new Tiger()); // OK, ctt 는 Cage<Tiger> 이거나 상위타입

Cage<Carnivore> cc = new Cage<>();
Cage<? super Tiger> ctt2 = cc; // OK
ctt2.push(new Tiger()); // OK, ctt2 는 Cage<Tiger> 이거나 상위 타입
```

### 참고 링크

- https://www.youtube.com/watch?v=PtM44sO-A6g
</details>


---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

### 답변

- 리플렉션은 동적으로 클래스의 정보를 얻어 사용할 수 있는 기법입니다. 주로 런타임에 클래스에 접근하여 정보를 얻어야 할 때 사용됩니다. 예시로는 Spring 의 애노테이션, Jackson 등이 있습니다.
### 정리

- 런타임에 클래스의 이름, 메서드, 필드 등을 동적으로 가져오는 API
- 클래스 정보가 런타임 시점에 필요할 때 이용
- Spring 의 애노테이션, IDE 의 자동완성, Jackson 등이 있다.
### 참고 링크

- https://velog.io/@alsgus92/Java-Reflection%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B8%EC%A0%9C%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C
</details>


<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary> 

### 답변

- 리플렉션의 장점으로는 클래스의 정보를 동적으로 로딩할 수 있다는 장점이 있습니다. 또한 객체를 런타임에 생성하여 유연성을 높일 수 있습니다. 반면 단점으로는 private 메서드에 접근할 수 있는 보안문제와 타입이 정해지지 않는 클래스의 정보를 동적으로 가져오기 때문에 성능 저하가 있습니다.
### 정리

#### 장점

- 클래스의 정보를 동적으로 로딩
- 객체를 런타임에 생성

#### 단점

- 타입이 정해지지 않는 클래스의 정보를 가져오기 때문에 컴파일러의 최적화를 받지 못한다. 이 때문에 성능 저하가 발생한다.
- 동적으로 클래스 정보를 가져오기 때문에 가독성이 떨어진다.
- private 메서드에 접근할 수 있기 때문에 보안문제가 생긴다.
### 참고 링크

- https://middleearth.tistory.com/72
</details>


---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary> 

### 답변

자바에서 직렬화는 시스템 내부에서 사용되는 객체 또는 데이터를 외부 시스템에서도 사용할 수 있도록 바이트 형태로 변환하는 기술입니다. 반면, 역직렬화는 바이트로 변환된 데이터를 객체로 변환하는 기술입니다.  
### 정리

#### 직렬화
- 시스템 내부에서 사용되는 객체 또는 데이터를 외부 시스템에서도 사용할 수 있도록 바이트 형태로 변환하는 기술
- JVM 의 메모리(힙 또는 스택)에 있는 객체 데이터를 변환
- 조건
  - 기본 타입 (primitive)
  - `java.util.Serializable` 인터페이스를 상속받은 객체
- 방법
  - `java.io.ObjectOutputStream` 객체 이용
#### 역직렬화
- 바이트로 변환된 데이터를 객체로 변환하는 기술
- JVM 의 메모리에 저장
- 조건
  - 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며, `import` 되어 있어야 한다.
    - 직렬화와 역직렬화를 진행하는 과정이 다른 시스템에서 일어날 수 있다.
  - 자바 직렬화 대상 객체는 동일한 `serialVersionUID` 를 가지고 있어야 한다.
- 방법
  - `java.io.ObjectInputStream` 객체 이용
#### 고려해야할 점
- 직렬화된 클래스는 추후에 변경하기 어렵다. (serialVersionUID 가 클래스의 해시값에 영향을 받기 때문)
- private, package-private 정보도 공개되기 때문에 정보 은닉의 기본 개념이 사라짐
- Serializable 을 구현하지 않는 부모 객체의 경우 자식 객체를 직렬화하기 위해서는 부모 클래스에 생성자를 만들어줘야 함
- inner class 는 Serializable 을 구현할 수 없다. 바깥 객체에 대한 참조를 가지고 있고, 바깥 유효범위의 지역 변수 값을 보관하기 위해 컴파일러가 자동으로 생성하는 인위생성 필드가 있기 때문.
### 참고 링크
- https://steady-coding.tistory.com/576
- https://wedul.site/393
- https://techblog.woowahan.com/2551
</details>

<details>
    <summary><b>자바의 직렬화는 언제, 어디서 사용되나요?</b></summary> 

### 답변
- JVM 의 메모리에서만 저장된 객체 데이터를 영속화할 때 사용합니다. 장점으로는 시스템이 종료되더라도 사라지지 않는 점이 있습니다. 예시로는 파일로 저장하는 서블릿 세션, 캐시 등이 있습니다.
### 정리
- 언제?
  - JVM 메모리에서만 있는 객체 데이터를 영속화할 때 사용
- 장점
  - 시스템이 종료되더라도 없어지지 않음
- 예시
  1. 서블릿 세션
     - 서블릿 기반의 WAS 들은 대부분 세션의 자바 직렬화를 지원하고 있다.
     - 세션을 통해 파일로 저장하거나 세션 클러스터링, DB 를 저장하는 등에서 세션 자체가 직렬화가 되어 저장되고 전달됨
  2. 캐시
     - 퍼포먼스를 위한 캐시 라이브러리(Ehcache, Redis, Memcached 등)에서 주로 이용
  3. 자바 RMI(Remote Method Invocation)
     - 자바 RMI: 원격 시스템 간의 메시지 교환을 위해서 사용하는 기술
       - 소켓 통신을 하지 않고 추상화하여 메서드를 통해 호출
     - 원격에 있는 메서드를 호출할 때 전달하는 메시지(주로 객체)를 직렬화
### 참고 링크
- https://techblog.woowahan.com/2550/
</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary>

### 답변
- Synchronized 키워드를 통하여 메서드나 코드 블록에 Lock 을 걸어 스레드 간 상호 배제를 할 수 있습니다. 메서드에 작성할 경우 해당 클래스 인스턴스에 Lock 을 걸고, 코드 블록에 작성할 경우 블록으로 작성된 부분만 Lock 이 걸리게 됩니다.
### 정리
- Lock 을 걸어 스레드 간의 상호배제를 할 수 있는 키워드.
- 적용 위치: 메서드, 코드 블록
#### 메서드에 적용
- 클래스 인스턴스에 Lock
#### static 메서드에 적용
- 클래스에 Lock
- static synchronized 메서드와 synchronized 메서드의 Lock 은 공유하지 않는다.
#### 메서드의 코드 블록에 적용
- 인스턴스의 블록 단위에 Lock 
- 동기화 전후에는 Lock 이 적용되지 않기 때문에, 효율적 사용 가능
- block 에 `this` 를 명시할 경우 메서드에 붙은 것과 같은 효과
  ```java
  public class Test {
    public void run() {
        // ...
  
        synchronized (this) {
            // ...
        }
  
        // ...
    }
  }
  ```
- block 에는 객체 인스턴스를 지정하거나 클래스를 지정할 수 있다.
#### static 메서드의 코드 블록에 적용
- 클래스에 Lock
- 코드 블록에 this 를 지정할 수 없다.
#### 동기화 순서
- Thread 의 동기화 순서를 보장하지 않는다.
### 참고 링크
- https://backtony.github.io/java/2022-05-04-java-50/
</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary> 

### 답변
- 동기화와 비동기화의 차이는 호출되는 함수의 반환을 신경쓰는지 여부와 연관이 있습니다. 호출되는 함수의 반환값을 기다리면 동기화, 기다리지 않으면 비동기화입니다. 자바에서 동기화는 synchronized 키워드를 통해 구현 가능하고, 비동기화는 Thread 클래스를 통해 구현할 수 있습니다.
### 정리
#### 동기화
- 호출되는 함수의 반환값을 기다린다. 반환이 되었으면 다음 흐름을 진행한다.
- synchronized 키워드
- Atomic 클래스
  - [CAS(Compare-And-Swap)](https://steady-coding.tistory.com/568) 알고리즘을 사용하여 lock 없이 동기화 처리 가능
  - lock 없이 동기화
- volatile
  - Main Memory 에 저장
  - 모든 스레드에서 Main Memory 에 읽기, 쓰기를 하기 때문에 값이 일치함
#### 비동기화
- 호출되는 함수의 반환값을 기다리지 않고 다음 흐름을 진행한다.
- Thread 를 통해 구현
### 참고 링크
- [동기화 처리 방법](https://dev-jj.tistory.com/entry/Java-Synchronize-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%B0%A9%EB%B2%95-3%EA%B0%80%EC%A7%80)
- [동기화 vs 비동기화](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0#3-synchronous%EB%8F%99%EA%B8%B0%EC%99%80-asynchronous%EB%B9%84%EB%8F%99%EA%B8%B0)
</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 

### 답변
- 동시성 문제란 동일한 자원에 대해 여러 스레드가 동시에 접근하면서 발생하는 문제입니다. 자바에서는 해당 쓰레드만 접근할수 있는 ThreadLocal 를 통해 해결할 수 있습니다. 하지만 ThreadLocal 의 사용이 끝나면 반드시 저장된 값을 제거하는 과정을 거쳐야합니다.
### 정리
- 동일한 자원에 대해 여러 스레드가 동시에 접근하면서 발생하는 문제
- 지역 변수에서는 발생하지 거의 발생하지 않고, 싱글톤, static 과 같은 공용 필드에서 주로 발생
- 읽기와 쓰기를 동시에 하는 경우에 발생
### 참고 링크
- https://backtony.github.io/java/2021-12-24-java-41/
</details>

<details>
    <summary><b>Thread Local에 대해 설명해주세요.</b></summary> 

### 답변
- 스레드마다 접근할 수 있는 개인 저장소를 의미합니다. ThreadLocal 의 데이터는 사용이 끝나면 반드시 삭제해야합니다. 스레드 풀 환경에서 사용이 완료된 데이터를 지워주지 않으면 재사용되는 스레드가 올바르지 않는 데이터를 참조할 수 있기 때문입니다.
### 참고 링크
- https://backtony.github.io/java/2021-12-24-java-41/
</details>


---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 

### 답변
- 인터페이스를 기반으로 한 문법으로 주석처럼 코드에 달아 특별한 의미를 부여하거나 기능을 주입할 수 있습니다. 어노테이션에는 크게 세가지 종류가 있습니다. JDK 에 포함되어 있는 build-in 어노테이션과 어노테이션의 정보를 나타내기 위한 Meta 어노테이션, 개발자가 직접 정의한 Custom 어노테이션이 있습니다.
### 정리
- 인터페이스를 기반으로 한 문법
- 사용
  - 컴파일러에게 필요한 정보 제공
  - 컴파일/배포 시 필요한 처리 기능
  - 런타임 처리 제공
- build-in 어노테이션
  - @Override
  - @Deprecated
  - @SuppressWarnings
  - @FunctionalInterface
  - ...
- 메타 어노테이션
  - @Target: 어노테이션이 적용 가능한 대상 지정
  - @Retention: 어노테이션이 유지되는 기간 지정
  - @Documented: javadoc 포함 여부 지정
  - @Inherited: 어노테이션의 상속 가능 여부 지정
  - @Repeatable: 어노테이션을 반복하여 적용 가능하도록 지정
#### 주의 사항
- @AllArgsConstructor, @RequiredArgsConstructor
  - 인스턴스 멤버의 순서가 변경되면 생성자의 순서도 변경되기 때문에 타입이 같은 경우 개발자가 인지하지 못할 수도 있다.
- @ToString
  - 양방향 관계에서 해당 어노테이션을 통해 순환참조가 일어날 수 있다.
- @Data
  - 위의 모든 문제가 일어날 수 있다.
### 참고 링크
- https://steady-coding.tistory.com/614
</details>

---

<details>
    <summary><b>자바 8에 추가된 기능들에 대해 간단히 설명해주세요.</b></summary> 

### 답변
- 자바 8에는 익명 함수를 단순하게 표기한 람다 표현식, 하나의 추상 메서드만 갖고 있는 함수형 인터페이스, 인터페이스의 default 메서드, 연속된 정보를 처리하는 Stream 클래스, null 처리를 간편하게 하기 위한 Optional 클래스 등이 있습니다.
### 정리
- 주요하게 추가된 것
  - Lambda
  - Functional Interface
    - 하나의 추상 메서드만 가지는 인터페이스
  - Stream
  - Optional
  - 인터페이스의 Default Method
  - 날짜 관련 클래스 추가
    - `ZoneDataTime`, `LocalDate`, `DateTimeFormatter`, `DayOfWeek`
  - 병렬 배열 정렬
    - parallelSort() 메서드 추가
  - StringJoiner
    - 순차적으로 나열되는 문자열 사이에 특정 문자열을 넣어줄 때 사용
### 참고 링크
- https://bbubbush.tistory.com/23
- https://medium.com/@inhyuck/java-8%EC%97%90-%EC%B6%94%EA%B0%80%EB%90%9C-%EA%B2%83%EB%93%A4-8c66023cbbae
</details>

<details>
    <summary><b>Stream에 대해 설명해주세요.</b></summary> 

### 답변
- 자바 8에 추가된 Collection 타입의 데이터를 처리하는 API 입니다. 주요 특징으로는 병렬 처리 용이하고 원본 데이터를 변경하지 못하며 재사용 불가능하고 최종 연산을 할 때 중간 연산이 실행된다는 점이 있습니다.
### 정리
- 자바 8에 추가된 Collection 타입의 데이터를 처리하는 API
#### 특징
- 병렬 처리 용이
  - parallel() 메서드 제공. (cf. [common fork join pool](https://m.blog.naver.com/tmondev/220945933678))
  - 코어 수가 많을수록, 처리할 데이터가 많을수록, 데이터당 처리 시간이 길수록 병렬 처리 성능 향상
- Immutable
  - 원본 데이터에 대한 변경 불가능
- Lazy
  - 중간 연산은 최종 연산에 이용될 때 값 계산
  - 중간 연산: filter, map, flatMat, limit, sorted, peek, ...
  - 최종 연산: foreach, reduce, findFirst, anyMatch, count, collect, ...
- 재사용 불가능
  - 최종 연산 완료 후 Stream 이 닫히므로 재사용 불가능
### 참고 링크

</details>

<details>
    <summary><b>Stream과 반복문 for문의 성능차이가 있을까요?</b></summary>

### 답변
- for 문은 단순 인덱스 기반으로 접근하고, 컴파일러가 최적화를 하기 때문에 성능이 더 빠릅니다. 특히 for 문은 기본 데이터 타입을 통해 접근하면 wrapper 타입에 비해 Heap 메모리에 접근하지 않아도 되서 성능이 더 올라가게 됩니다.
### 참고 링크
- https://pamyferret.tistory.com/49
</details>

<details>
    <summary><b>Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해주세요.</b></summary> 

### 답변
- 사용할 수 있는 함수형 인터페이스로는 인자를 받지 않고 반환만 하는 Supplier, 인자를 받고 반환은 하지 않는 Consumer, 인자를 받고 반환을 하는 Function, 인자를 받아서 참 거짓을 판단하는 Predicate 등이 있습니다. 
### 참고 링크
- https://bcp0109.tistory.com/313
</details>

<details>
    <summary><b>Lambda에 대해 설명해주세요.</b></summary> 

### 답변
- Lambda 는 자바 8에서 추가되어 메서드를 하나의 식으로 표현할 수 있는 익명 함수입니다. 함수형 인터페이스를 통해 정의할 수 있으며 기존 익명 함수로 작성하던 코드를 줄일 수 있다는 장점이 있습니다.
### 정리
- 자바 8에서 추가되어 메서드를 하나의 식으로 표현하는 익명 함수
- 함수형 인터페이스를 통해서 사용 가능
- 장점
  - 기존 익명 함수로 작성하던 코드를 줄일 수 있다.
  - 가독성이 증가된다.
  - 병렬 프로그래밍에 용이하다.
- 단점
  - 남용시 코드 이해가 어렵다.
  - 재귀 활용과 디버깅이 어렵다.
### 참고 링크

</details>

<details>
    <summary><b>익명 클래스(Anonymous Inner Class)와 Lambda의 차이점을 알고계신가요?</b></summary> 

### 답변
- 익명 클래스는 클래스를 의미하고 여러 메서드를 포함할 수 있지만, Lambda 는 익명 메서드를 의미합니다. 또한 익명 클래스의 this 는 새로 생성된 클래스 객체를 의미하고 Lambda 의 this 는 Lambda 를 정의한 클래스를 의미합니다.
### 정리
#### 익명 클래스
- 이름 없는 클래스
- 추상 및 구체 클래스 확장 O
- 여러 추상 메서드를 포함하는 인터페이스 구현 O
- 익명 클래스 생성 시 인스턴스 변수 선언 O
- 익명 내부 클래스 인스턴스화 O
- this 키워드가 생성된 익명 클래스 객체를 의미
#### Lambda
- 이름 없는 메서드
- 추상 및 구체 클래스 확장 X
- 여러 추상 메서드를 포함하는 인터페이스 구현 X
- 익명 클래스 생성 시 인스턴스 변수 선언 X
- 익명 내부 클래스 인스턴스화 X
- this 키워드가 생성된 Lambda 가 정의된 클래스를 의미
### 참고 링크
- https://developer-talk.tistory.com/499
</details>

<details>
    <summary><b>람다식에서, 외부 변수를 사용할 때 final 키워드를 붙여서 사용하는 이유가 무엇일까요? final을 안 붙여도 되지 않을까요?</b></summary> 

### 답변
- 외부 지역 변수를 제어하는 스레드와 람다식을 제어하는 스레드가 다를 수 있기 때문입니다. 이 경우 각 스레드간 스택 영역이 다르기 때문에 값을 공유할 수 없고, 동기화할 수 없기 때문에 외부 변수가 최신 값으로 변경이 되었는지 확신할 수 없습니다. 따라서 매번 다른 결과가 도출될 수 있기 때문에 final 키워드를 붙여야 합니다.
### 참고 링크
- https://vagabond95.me/posts/lambda-with-final/
</details>


<details>
    <summary><b>Optional에 대해 설명해주세요. Optional을 사용하면 무슨 이점이 있을까요?</b></summary> 

### 답변
- Optional 은 Null 이 될 수 있는 값을 감싸는 Wrapper 클래스입니다. 명시적으로 Null 가능성을 표현할 수 있고, Null 체크를 직접 하지 않아도 되고, NPE 가 발생할 가능성이 있는 값을 직접 다룰 필요가 없다는 점이 장점입니다.
### 정리
- Null 이 될 수 있는 값을 감싸는 Wrapper 클래스
- 장점
  - 명시적으로 변수에 대한 Null 가능성을 표현할 수 있다.
  - Null 체크를 직접 하지 않아도 된다.
  - Null Pointer Exception 이 발생할 가능성이 있는 값을 직접 다룰 필요가 없다.
- 단점
  - Wrapper 클래스이기 때문에 생성 비용이 비싸다.
  - 직렬화가 불가능하기 때문에 클래스의 인스턴스 필드로 사용하면 안된다.
  - 필드로 사용하기 위해 고안된 것이 아니므로 값을 반환하는 용도로 사용해야 한다.
### 참고 링크
- https://tecoble.techcourse.co.kr/post/2021-06-20-optional-vs-null/
</details>

<details>
    <summary><b>Optional을 사용하면서 주의해야할 점이 있을까요?</b></summary> 

### 답변
- Optional 은 직렬화를 구현하지 않았기 때문에 필드로 사용하는 것을 주의해야 합니다. 또한 생성자나 메서드 인자로 사용하는 것을 주의해야 합니다. 생성 비용이 비싼 Optional 대신 일반 객체를 넘겨 null 체크를 하는 것이 좋습니다.
### 정리
- 필드로 사용하지 말자
  - Optional 은 Serializable 을 구현하지 않았기 때문에 직렬화가 되지 않는다.
- 생성자나 메서드 인자로 사용하지 말자
  - 생성비용이 비싼 Optional 대신 일반 객체를 넘겨 호출받는 쪽에서 null 체크를 하자. Optional 이 오더라도 Optional 에 null 이 할당되어 있을 수도 있다.
- orElse 대신 orElseGet 을 사용하자
  - null 일 경우에만 반환하는 코드가 호출되므로 더 효율적이다.
- 컬렉션을 Optional 로 감싸지 말자
### 참고 링크
- https://velog.io/@hope1213/Optional%EC%9D%80-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EC%A7%80-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD
</details>

---

<details>
    <summary><b>Object 클래스의 equals()와 hashcode()는 무슨 역할을 하나요?</b></summary>

### 답변
- equals 는 객체의 내부 요소를 비교하여 객체의 동등성을 확인할 떄 사용합니다. hashcode 는 런타임 시점에 객체의 유일한 값을 반환하는 것입니다. 이는 HashMap, HashTable 등 여러 Collection 클래스에서 객체끼리 구분할 때 사용합니다.
### 정리

### 참고 링크
- https://mangkyu.tistory.com/101
- https://olivejua-develop.tistory.com/65
</details>

<details>
    <summary><b>equals()와 hashcode()는 언제 재정의해야할까요? 또, 왜 같이 오버라이딩 하는게 좋을까요?</b></summary> 

### 답변
- equals 를 재정의하지 않으면 객체의 주소값만 비교하는 것이 기본 구현입니다. 하지만 객체가 같은 값을 가질 때 같은 객체로 인식하기 위해서는 클래스의 필드에 맞게 재정의가 필요합니다. hashcode 는 객체간의 구분을 위해 사용하므로 유일하게 객체를 식별할 때 재정의해야 합니다. Object 의 명세에 의하면 equals 가 동일하면 동일한 해시코드를 반환해야 합니다. 이 때문에 같이 오버라이드 해야합니다.
### 정리
- equals 만 구현했을 때 문제점
  - 만약 equals 만 구현하여 동등한 객체로 인식되는데 다른 해시 값이 나온다면, Object 명세에도 어긋나지만, 의미상으로도 이상하다. 동등한 객체인데 HashMap 이나 다른 Collection 객체에서는 다른 객체로 인식되는 문제가 생긴다.
- hashcode 만 구현했을 때 문제점
  - 만약 hashcode 만 구현하여 동일한 해시코드가 나오는데 동등성이 보장되지 않는다면, 마찬가지로 Collection 객체에서 같은 객체로 인식했는데 equals 메서드를 통해 비교할 때는 다르다는 결과가 나오게 된다. 이는 프로그램의 잠재적인 위험이 된다.
- hashcode 를 구현할 때 주의할 점
  - 핵심 필드를 꼭 포함해서 구현하자
    - 성능보다는 핵심필드를 포함하자
  - 자세한 구현 사항을 API 사용자는 모르는 것이 좋다.
    - 사용자가 구현에 의존하지 않을 수 있다.
### 참고 링크

</details>

<details>
    <summary><b>서로 다른 인스턴스가 같은 hashcode값을 가질 수 있을까요?</b></summary> 

### 답변
- 서로 다른 인스턴스더라도 해시코드 값을 가질 수 있습니다. 이때문에 해시 충돌을 해결하는 것이 중요해졌습니다. 해시 충돌을 완화하는 방법에는 크게 Open Addressing 과 Separate Chaining 방식이 존재합니다. 자바의 HashMap 에서는 Separate Chaining 방식을 사용하며, 이는 해시 버킷에 들어갈 수 있는 엔트리의 제한을 두지 않는 방식입니다.
### 정리
#### Open Addressing
- 한 버킷당 들어갈 수 있는 엔트리가 하나
- 해시 충돌이 일어난 경우, 다른 버킷에 저장
- 이를 위해 빈 버킷을 찾는 여러 알고리즘이 존재한다.
  - Linear probing
  - Quadratic probing
  - Dobule hasing
- 특징
  - 전체 버킷 중 사용중인 버킷의 비율이 커지면 탐사 비용이 비약적으로 상승한다.
  - 데이터를 삭제할 때 비효율적이다.
#### Separate Chaining
- 한 버킷에 여러 엔트리가 들어갈 수 있음
- 버킷은 주로 LinkedList 또는 Tree 를 사용
- 특징
  - 위의 방식과 비교하여 추가적인 메모리 공간 필요
  - 적재율에 따라 선형적으로 성능이 저하됨
#### 자바에서의 hash 충돌 발생 해결 방법 (HashMap)
- Separate Chaining
- Java 7 까지는 LinkedList 를 고정적으로 사용
- Java 8 부터 데이터의 개수에 따라 적으면 LinkedList, 많으면 Tree 사용
### 참고 링크
- https://d2.naver.com/helloworld/831311
- https://dkswnkk.tistory.com/679
</details>


---

<details>
    <summary><b>String 클래스는 final로 선언되어있습니다. 왜 그런걸까요?</b></summary> 

### 답변
- String 클래스가 final 로 선언되면서 불변성을 가지게 되었습니다. 이 이유로는 String Pool 을 통한 메모리 절약, 다수의 클래스에 매개변수로 사용되기 때문에 보완 관련 문제, 해시 기반 Collection 의 키 값으로 사용하기 위함 등이 있습니다.
### 정리
#### String Pool
- String 은 자바를 설계할 때 가장 많이 사용할 것으로 예상된 데이터 타입이다.
- 이를 최적화하기 위해 String Pool 에 String 리터럴을 포함하는 방법을 이용했다.
- String 객체를 공유하여 잉여 객체 생산을 막는 것이 목표이다.
- 이를 위해서는 final 또는 불변이어야 가능하다.
#### Security
- String 은 다수의 자바 클래스의 매개 변수로 쓰이고 있다. 
- 만약 String 이 불변이지 않으면, String 의 조작을 통해 시스템의 특점 파일에 대한 액세스 권한을 얻는 등 심각한 보안 문제가 발생한다.
#### Multithreading
- 자바에서 멀티 스레드를 지원하기 위해 String 객체는 thread safe 를 보장해야 한다.
#### Optimization and Performance
- String 을 불변 클래스로 만들면서 성능 최적화를 할 수 있게 되었다.
- 값이 변경되지 않는 것을 이용해서 해시 코드 값을 lazy 하게 계산하고 일단 생성 되면 String Pool 에 캐싱한다.
- 이를 통해 한번 계산된 해시 코드 값을 계속 사용하는 등 성능 개선을 할 수 있다.
- HashMap 등 해시 관련 함수에 이용할 시 성능 향상의 원인이 된다.
### 참고 링크
- https://wildeveloperetrain.tistory.com/34
</details>


<details>
    <summary><b>String을 new 또는 "" 로 생성했을 때의 차이점을 설명해주세요.</b></summary> 

### 답변
- String 을 "" 와 같이 리터럴로 생성했을 때는 String Pool 에 캐시됩니다. 따라서 객체를 재활용하는 특징이 있습니다. 반면, new 키워드로 생성했을 때는 다른 객체와 똑같이 Heap 메모리에 생성되고 객체를 공유하지 못하는 특징이 있습니다.
### 정리
#### String Pool 도 GC 가 될까?
- Java 7 이전
  - String Pool 은 PermGen 이라는 곳에 저장되어 있었습니다.
  - 이 공간은 런타임에 확장할 수 없고, GC 에 적합하지 않습니다.
  - 그리고 일반 Heap 메모리에 비해 공간이 작아서 문자열을 많이 생성할 경우 메모리 부족 에러가 발생했습니다.
- Java 7 이후
  - String Pool 은 이후 일반 Heap 공간에 저장되고 이는 GC 대상이 되는 공간입니다.
  - 이 방식을 통해 참조되지 않은 문자열을 풀에서 제거해 메모리 부족 위험이 줄어들었습니다.
### 참고 링크
- https://www.mimul.com/blog/why-string-class-has-made-immutable-or-final-java/
- https://junghyungil.tistory.com/210
</details>

<details>
    <summary><b>String, StringBuilder, StringBuffer 를 각각 비교해주세요.</b></summary> 

### 답변
- String 은 다른 두 클래스와 다르게 새로운 값을 할당할 때마다 새로운 클래스에 대한 객체가 생성됩니다. 또한 + 연산을 통해 String 객체를 합치는 경우 GC 되기 전까지 메모리에 부하를 주게 됩니다. 이와 반대로 StringBuilder, StringBuffer 는 메모리에 append 하는 방식으로 클래스에 대한 객체를 생성하지 않습니다. 다만 이 둘의 차이는 StringBuilder 는 thread safe 하지 않고, StringBuffer 는 thread safe 하다는 점이 있습니다.
### 정리
- JDK 1.5 이전 버전
  - 문자열 연산을 할 때 각 리터럴마다 새로운 메모리를 할당
- JDK 1.5 이후 버전
  - 문자열 연산을 할 때 컴파일 과정에서 StringBuilder 로 컴파일 되도록 변경
  - 단 반복문을 사용하여 문자열 연산을 할 경우 이전과 똑같이 새로운 메모리 할당
- 성능
  - StringBuilder > StringBuffer >>> String
### 참고 링크
- https://12bme.tistory.com/42
</details>

---

<details>
    <summary><b>컬렉션 프레임워크에 대해 설명해주세요.</b></summary> 

### 답변
- 컬렉션 프레임워크는 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 클래스의 집합입니다. 주요 인터페이스로는 List, Set, Map, Queue 등이 있습니다. 이중 Map 은 다른 것들과 특징이 달라 Iterable 을 상속하고 나머지는 Collection 을 상속합니다. 장점으로는 효율적이고 빠른 코드 작성을 할 수 있습니다.
### 정리
- 정의: 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 클래스 집합
- 특징
  - 가변적
  - 데이터 삽입, 탐색, 정렬 등 편리한 API 다수 제공
  - JDK 1.2 버전부터 지원
    - 초기에는 Vector, Properties, Stack, HashTable, Dictionary 등이 제공되고, 통일성있고 표준화된 인터페이스가 존재하지 않았다.
- 장점
  - 다수의 데이터 처리를 직접 구현하지 않고 사용하면 되서 편리하다.
  - 효율적인 데이터 처리로 인해 성능 향상이 있다.
- 종류
  ![collection_hierarchy.png](collection_hierarchy.png)
  - List
  - Queue
  - Set
  - Map
### 참고 링크
- https://hudi.blog/java-collection-framework-1/
- https://www.geeksforgeeks.org/how-to-learn-java-collections-a-complete-guide/
- https://dzone.com/articles/top-java-collection-interview-questions-for-2021?fbclid=IwAR0Tr4Pqpl9wSNlz9AiED50kgZNom329Q_HlaMCS9AuXtthAaoMznl53ScI
</details>

---

<details>
    <summary><b>List 인터페이스의 구현체에 대해 설명해주세요.</b></summary> 

### 답변
- List 의 구현체로는 ArrayList, LinkedList, Vector, Stack 이 존재합니다. ArrayList 는 배열처럼 연속된 메모리에 저장되어 검색은 용이하나 삽입, 삭제에는 부적절합니다. LinkedList 는 양방향 포인터 구조로 데이터 검색보다는 삽입과 삭제가 빈번하게 일어나는 경우에 유용합니다. Vector 는 ArrayList 와 동일하게 배열로 구현되어있고 내부에서 동기 처리가 일어나는 것이 특징입니다. 마지막으로 Stack 은 Vector 를 상속받아 동기 처리가 일어납니다.
### 정리
#### ArrayList
- 내부적으로 배열을 사용하여 메모리가 연속적으로 저장된다.
- 배열과 달리 메모리가 동적이다.
- 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터의 복사가 이루어지므로 빈번한 삽입, 삭제는 비효울적이다.
- 인덱스를 통해 검색하므로 검색에 효율적이다.
#### LinkedList
- 양방향 포인터 구조로 저장된다.
- 데이터의 삽입, 삭제 시 포인터의 위치만 바꾸면 되기 때문에 효율적이다.
- 데이터 검색 시 포인터를 타면서 순회하기 때문에 비효율적이다.
#### Vector
- 내부적으로 배열을 사용한다.
- 동기화 처리를 하여 Thread Safe 하다.
- 성능이 좋지 않고 무거워 잘 쓰이지 않는다.
- 멀티 스레드 환경에서도 ArrayList 를 활용하는 것이 좋다.
  ```java
  class MyList {
    ArrayList<T> list = new ArrayList<>(Collections.synchronizedList());
  }
  ```
#### Stack
- Vector 를 상속받아 구현하였다.
- 동기화 처리를 하여 Thread-safe 하다.
### 참고 링크
- https://hudi.blog/java-collection-framework-2/
</details>

<details>
    <summary><b>Array와 ArrayList는 어떤 차이점이 있을까요?</b></summary> 

### 답변
- Array 와 ArrayList 의 차이는 길이의 가변성, 제네릭 지원, 기본 데이터 타입 저장 유무에 차이가 있습니다. 배열은 길이가 불변에 제네릭을 지원하지 않고 기본 데이터 타입을 저장할 수 있고, ArrayList 는 길이가 가변이고 제네릭을 지원합니다. 기본 데이터 타입은 저장할 수 없습니다.
### 정리

### 참고 링크
- https://xperti.io/blogs/difference-between-java-array-vs-arraylist/
</details>

<details>
    <summary><b>ArrayList는 내부적으로 어떻게 구현되어있나요?</b></summary> 

### 답변
- ArrayList 는 내부적으로 Array 로 구현되어 있습니다. 삽입시 데이터를 배열에 저장하고 만약 크기가 가득 찼다면, 크기를 늘린 새로운 ArrayList 에 모든 데이터를 복사한 후 삽입합니다.
### 참고 링크

**🆀 배열로 구현되어있으면 크기가 꽉 찬 경우 일반 배열처럼 예외가 발생할텐데 ArrayList 는 어떻게 무한히 데이터를 받을 수 있을까요?** 
```java
class ArrayList<T> {
  // ...

  private Object[] grow(int minCapacity) {
    int oldCapacity = elementData.length;
    if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
      int newCapacity = ArraysSupport.newLength(oldCapacity,
              minCapacity - oldCapacity, /* minimum growth */
              oldCapacity >> 1           /* preferred growth */);
      return elementData = Arrays.copyOf(elementData, newCapacity);
    } else {
      return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    }
  }
  
  private void add(E e, Object[] elementData, int s) {
    if (s == elementData.length)
      elementData = grow();
    elementData[s] = e;
    size = s + 1;
  }
  
}
```
**※ Ref**

- https://f-lab.kr/blog/java-backend-interview-1

</details>


<details>
    <summary><b>ArrayList 와 LinkedList를 비교해주세요.</b></summary> 

### 답변
- ArrayList 는 배열로 구현되어 메모리에 순차적으로 데이터가 저장되게 됩니다. 이러한 특성 때문에 데이터를 검색할 때 인덱스를 통해 찾을 수 있어 효율적입니다. 하지만 삽입 또는 삭제 시 해당 데이터의 이후 데이터들을 모두 복사하는 과정이 필요하므로 빈번한 삽입, 삭제에는 비효율적입니다. 반면, LinkedList 는 양방향 포인터 구조로 되어있어 데이터가 메모리에 불연속적으로 저장됩니다. 데이터와 데이터 사이의 포인터를 통해 연결되어 삽입, 삭제 시 포인터만 바꾸면 되서 효율적이지만 검색 시 데이터들을 순회해야 하기 때문에 비효율적입니다.
### 참고 링크

</details>

---