<details>
  <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

### 답변

장점으로는 JVM에서 동작하기 때문에 운영체제에 독립적이고 객체지향 언어이기 때문에 이해하기가 쉽습니다. 또한 가비지 컬렉터에 의해 메모리를 자동으로 관리해준다는 점이 있습니다.
단점으로는 JVM 에 의해 번역되는 과정이 필요하기 때문에 비교적 느립니다. 또한 가비지 컬렉터로 인하여 비교적 많은 메모리 공간이 필요합니다.

### 정리

- 장점
    - JVM에서 동작하기 때문에 운영체제에 독립적
    - 객체지향 언어이기 때문에 이해하기 쉽다.
    - 오픈소스로 사용할 수 있고 커뮤니티가 잘 발달되어 있다.
    - 멀티쓰레드를 쉽게 구현할 수 있다.
    - 가비지 컬렉터에 의해 메모리 관리를 자동으로 해준다.
- 단점
    - 컴파일되고 번역하는 과정을 거치기 때문에 비교적 느리다.
    - 가비지 컬렉터로 인해 메모리 공간 필요

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90
- https://data-flair.training/blogs/pros-and-cons-of-java/

</details>

---

<details>
  <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

### 답변

자바의 데이터 타입은 기본 데이터 타입과 참조 타입으로 나뉩니다. 기본 데이터 타입으로는 byte, short, int, long, float, double, boolean, char 가 있으며 Stack 영역에
저장됩니다. 참조 타입은 기본형은 제외한 모든 타입이며, Heap 영역에 저장됩니다.

### 정리

- 기본 데이터 타입(Primitive Data Type)
    - 정수형 : byte, short, int, long
    - 실수형 : float, double
    - 논리형 : boolean(ture/false)
    - 문자형 : char
    - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.
- 참조 타입(Reference Data Type)
    - 참조 타입 종류: class, array, interface, Enumeration
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용하여 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이다.
    - String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
    - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
    - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
    - 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85

</details>

<details>
  <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

### 답변

Wrapper 클래스는 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스입니다. 기본 타입의 데이터를 Wrapper 클래스의 값으로 변환하면 Boxing,
반대의 경우를 Unboxing이라고 합니다.

### 정리

- Wrapper Class
    - 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스
    - java.lang 패키지에 존재

| 기본 타입     | 래퍼 클래스      |
|-----------|-------------|
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

- Boxing
    - 기본 타입의 데이터를 Wapper 클래스의 인스턴스로 변환하는 과정
- Unboxing
    - Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 꺼내는 과정

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#wrapper-class

</details>

---

<details>
  <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary> 

### 답변

자바는 Call by Value 를 따릅니다. 기본 자료형의 경우 해당 값이 복사되어 전달되고, 참조 자료형의 경우 힙 메모리의 참조값이 복사되어 전달됩니다.

### 정리

- 자바에서 파라미터는 항상 `값`으로 전달됩니다. (파라미터의 복사본이 메서드에 전달)
- 기본 자료형의 경우 값의 복사본이 전달됩니다.
- 참조 자료형의 경우 힙 메모리의 주소값이 복사되어 전달됩니다.
    - 아래 예시의 경우 User 의 메모리가 복사되어 전달된다. b 의 경우 새로운 주소를 할당하는데 메서드가 종료되면 원본 b 에는 반영되지 않는다.
  ```java
  class User {
      public int age;
  
      public User(int age) {
          this.age = age;
      }
  }
  
  public class ReferenceTypeTest {
  
      void test() {
          User a = new User(10);
          User b = new User(20);
  			  
          System.out.println(a); // age: 10
          System.out.println(b); // age: 20
          modify(a, b);
  
          System.out.println(a); // age: 11 
          System.out.println(b); // age: 20
      }
  
      private void modify(User a, User b) {
          a.age++;
  
          b = new User(30);
          b.age++;
      }
  }
  ```

### 참고 링크

- https://bcp0109.tistory.com/360
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#call-by-reference%EC%99%80-call-by-value%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

### 답변

자바의 접근 제어자로는 제약 없이 접근 가능한 public, 동일 패키지 또는 상속 관계에서 접근 가능한 protected, 동일 패키지에서만 접근 가능한 package-private, 선언한 객체에서만 사용 가능한
private 이 있습니다.

### 정리

| 접근 제어자	           | 설명                             |
|-------------------|--------------------------------|
| `public`          | `해당 객체를 사용하는 프로그램 어디에서나 접근 가능` |
| `protect`         | `동일 패키지 또는 상속 관계의 객체에서 접근 가능`  |
| `package-private` | `동일 패키지에서 접근 가능`               |
| `private`         | `해당 객체에서만 사용 가능`               |

### 참고 링크

- http://www.tcpschool.com/java/java_modifier_accessModifier
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95

</details>

---

<details>
  <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

### 답변

클래스는 객체를 만들어 내기 위한 틀로서 객체가 가질 수 있는 속성과 메서드를 정의하며, 이를 실체화한 것이 객체입니다. 인스턴스는 객체의 구체적인 사례입니다.

### 정리

- 클래스(Class)
    - 객체를 만들어 내기 위한 설계도 혹은 틀
    - 연관되어 있는 변수와 메서드의 집합
- 객체(Object)
    - 소프트웨어 세계에 구현할 대상
    - 클래스에 선언된 모양 그대로 생성된 실체
    - '클래스의 인스턴스(instance)' 라고도 부른다.
- 인스턴스(Instance)
    - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
        - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
        - 실체화된 인스턴스는 메모리에 할당된다.

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

### 답변

클래스 멤버를 정의할 때 사용되며, 객체가 생성되기 전에 초기화 되며, 모든 인스턴스에서 공유되어 사용됩니다.

### 정리

- 클래스 멤버를 정의할 때 사용
- 객체가 생성되기 전에 클래스의 로딩 과정에서 메모리에 할당되므로, 객체 생성 없이 클래스 이름만으로 접근할 수 있다.
- static 키워드를 적절히 사용하면, 메모리를 효율적으로 사용하거나 객체 생성 없이도 편리하게 접근할 수 있는 장점이 있다.

<details> <summary>클래스 멤버와 인스턴스 멤버</summary>
- 클래스 멤버: 클래스에 존재하는 변수와 메서드.
- 인스턴스 멤버: 객체(인스턴스)에 존재하는 변수와 메서드. static 키워드를 사용하지 않고 정의한다.
- 클래스 멤버에서는 인스턴스 멤버가 접근 가능하지만, 인스턴스 멤버에서는 클래스 멤버로 접근이 불가능하다.
  ![](../../../../../var/folders/1q/jkln67w958d9zskbyx2v6p940000gn/T/TemporaryItems/NSIRD_screencaptureui_x5cM7o/스크린샷 2023-03-31 오전 3.08.16.png)
</details>

### 참고 링크

- [클래스 멤버와 인스턴스 멤버](https://hyuntaekhong.github.io/blog/java-basic12/)

</details>

<details>
  <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary> 

### 답변

- static 멤버는 클래스가 로딩될 때 메모리에 할당되며, 모든 인스턴스에서 공유됩니다. 반면에 non-static 멤버는 각 인스턴스가 생성될 때 메모리에 할당되고, 인스턴스마다 고유한 값을 가집니다.

### 정리

- 다음과 3가지의 차이점이 존재한다.

| 항목           | 메모리 할당 시기   | 접근 방법                     | 공유 여부             |
|--------------|-------------|---------------------------|-------------------|
| `static`     | 클래스가 로딩될 때  | 인스턴스를 생성하지 않고 클래스 이름으로 접근 | 모든 인스턴스가 동일한 값 공유 |
| `non-static` | 인스턴스가 생성될 때 | 인스턴스를 생성한 후 접근            | 인스턴스마다 고유한 값 존재   |

### 참고 링크

</details>

<details>
  <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

### 답변

- main 메서드는 프로그램이 실행될 때 가장 먼저 호출됩니다. 인스턴스가 생성되기 전에 호출되어야 하기 때문에 static으로 정의되어야 합니다.

### 정리

- main 메서드는 프로그램이 시작할 때 JVM에 의해 호출됩니다. 만약 non-static 메서드라면, main 메서드를 호출하기위해 클래스를 인스턴스화 시켜야 하기 때문에 JVM 에서 직접 호출이 불가능합니다.
  따라서 main 메서드는 static 메서드여야 합니다.

### 참고 링크

- https://www.scaler.com/topics/why-main-method-is-static-in-java/

</details>

<details>
  <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

### 답변

- static 이 붙은 변수는 해당 클래스가 로딩될 때 Method Area에 한번 초기화되고 값 변경이 일어나지 않습니다. 이후에 인스턴스를 초기화하지 않고 사용할 수 있습니다.

### 정리

- 자바 프로그램이 실행되고 JVM이 프로그램에서 사용되는 클래스를 로드하고, 해당 static 변수를 초기화합니다.
- JVM은 Method Area 에 static 변수에 메모리를 할당합니다.

### 참고 링크

</details>

---

<details>
  <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

### 답변

- 오버로딩은 메서드의 이름은 같고 파라미터를 다르게 한 것이고, 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 의미합니다.

### 정리

- 오버로딩
    - 이름은 같고 매개변수의 수, 타입 또는 순서가 다른 여러 메서드 정의
    - 반환하는 타입은 달라도 된다.
- 오버라이딩
    - 메서드 이름과 매개변수가 동일한 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것
    - 오버라이딩된 메서드가 자식클래스의 인스턴스에서 호출되면 부모 클래스의 메서드는 무시된다.

### 참고 링크

- https://hyoje420.tistory.com/14

</details>

---

<details>
  <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

### 답변

- 둘의 차이는 목적에 있어 차이가 있습니다. 추상클래스는 abstract 키워드로 선언된 클래스로서 기능을 이용하고 확장하도록 의도합니다. 반면, 인터페이스는 추상메서드로만 이루어진 것으로 기능의 구현을 강제하도록 의도합니다. 이때문에 추상클래스는 공통 기능을 가지는 기반 클래스로 적합하며, 인터페이스는 다형성이 필요한 경우에 적합합니다. 
### 정리

#### 추상클래스
- abstract 키워드로 선언된 클래스
- 자식 클래스가 추상클래스의 기능을 이용하고 확장하는데 초점을 둔다.
- 클래스이기 때문에 다중상속은 지원하지 않는다.
- 기능의 확장에 초점을 두기 때문에 공통 기능을 가지는 베이스 클래스에 적합하다.
#### 인터페이스
- 추상 메서드와 상수로만 이루어진 것
- 인터페이스는 선언된 기능을 구현하도록 강제한다.
- 기능의 구현을 강제하기 때문에 같은 기능을 다르게 구현하는 다형성이 필요한 경우에 적합하다.
- 다중 상속이 가능하다.
  - 다중 상속을 할 때 메서드 충돌은 어떻게 해결할까?
    - 다중 상속을 하더라도 인터페이스에는 구현부가 없고, 구현 부분이 하나이기 때문에 컴파일 에러는 나타나지 않는다.
    - 다만, default 메서드를 통해 인터페이스에서 구현하는 경우 컴파일러는 오류를 내보낸다. (모두 구현된 경우)
    - 이 경우 2가지 해결 방법이 존재한다.
      1. 인터페이스에서 구현하지 않고 상속한 클래스에서 구현한다.
      2. 하나의 인터페이스로 구현을 위임한다.
#### 추상 메서드
- abstract 키워드와 함께 구현부는 작성되지 않고 선언부만 작성된 메서드
- final 키워드가 붙은 메서드는 추상 메서드로 만들 수 없다.
- 물론 static 메서드도 추상 메서드로 만들 수 없다.
### 참고 링크

- https://brunch.co.kr/@kd4/6
- [static 메서드가 추상메서드 될 수 없는 이유](https://stackoverflow.com/questions/370962/why-cant-static-methods-be-abstract-in-java)
- [다중상속 시 메서드 충동 해결](https://webfirewood.tistory.com/130)
</details>

<details>
    <summary><b>클래스는 왜 다중 상속을 허용하지 않을까요?</b></summary> 

### 답변

- 다중 상속을 허용하지 않는 이유는 모호성때문입니다. 다중 상속하는 클래스에서 이름이 같은 메서드가 있다면 어떤 메서드를 컴파일러가 호출할지 모호하기 때문에 자바에서는 다중 상속을 지원하지 않습니다.
### 정리

- 자바에서는 모호성때문에 다중 상속을 지원하지 않는다.
- 부모 클래스들에서 같은 이름을 가진 메서드나 변수가 있다면, 자식 클래스에서 어떤 메서드를 컴파일러가 호출할지 모호하기 때문이다.  
### 참고 링크

- https://siyoon210.tistory.com/125
</details>

---

<details>
  <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary> 

### 답변

- 자바의 Error 와 Exception 은 모두 Throwable 객체를 상속받습니다. Error 는 주로 시스템 레벨의 심각한 에러로서 개발자가 처리할 수 없는 에러입니다. 반면, Exception 은 크게 RuntimeException 과 다른 Exception 으로 구분되며, 주로 개발자가 작성한 프로그램에서 발생하는 에러입니다. 
### 정리

#### Error
- 시스템에 발생하는 심각한 예외 상황을 나타냄
- OutOfMemoryError, StackOverflowError 등
- 시스템 자체에서 발생하여 개발자가 대응할 수 없다. -> 따로 처리하지 않아도 된다.
#### Exception 
- 개발자가 작성한 프로그램에서 발생하는 예외 상황을 나타냄
- RuntimeException, IOException 등
- 일반적으로 RuntimeException 과 나머지 Exception 으로 구분되어 구조화한다.
- try-catch-finally 구문을 사용하여 예외 처리를 해야한다.
### 참고 링크

</details>

<details>
  <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

### 답변

- UncheckedException 와 CheckedException 의 차이는 예외 처리의 강제성에 있습니다. CheckedException 은 컴파일 과정에서 발생하여 예외를 강제하는 반면, UncheckedException 은 런타입 과정에서 발생하는 예외이기 때문에 컴파일 과정에서 예외 처리를 강제하지 않습니다. 
### 정리

#### UncheckedException

- RuntimeException 과 이를 상속한 예외
- 런타임 과정에서 발생하는 예외
- 예외 처리를 강제받지 않음
  - 다만 예외가 런타임 과정에서 발생하기 때문에 예상하지 못한 에러가 발생할 수 있다.
  - 따라서 예외 상황이 발생할 것을 대비하여 예외 처리를 하는 것이 좋다.
#### CheckedException

- RuntimeException 을 제외한 Exception 예외
- 컴파일 과정에서 발생하는 예외
- 컴파일러에 의해 예외 처리가 강제됨
### 참고 링크

</details>

<details>
    <summary><b>예외처리의 세 가지 방법을 설명해주세요.</b></summary> 

### 답변

- 예외 처리 방법으로 예외 상황을 정상 상태로 돌려놓는 예외 복구, 호출한 메서드로 예외 처리를 넘기는 예외 회피, 다른 예외로 전환하는 예외 전환이 있습니다.
### 정리

#### 예외 복구
- 예외가 발생하더라도 애플리케이션이 정상적인 흐름으로 동작하도록 진행
#### 예외 회피
- 예외가 발생하면 throws 를 통해 호출한 메서드로 예외 처리를 위임하는 것
#### 예외 전환
- 다른 예외로 전환.
- 호출한 메서드에서 예외를 처리할 때 더 명확하게 예외 상황을 인지할 수 있도록 돕는다.
- throw 를 통해 실행
### 참고 링크

- https://www.nextree.co.kr/p3239/
</details>

---

<details>
    <summary><b>final 키워드는 왜 사용할까요? 어떤 이점이 있을까요?</b></summary>

### 답변

- final 키워드는 변수와 메서드, 클래스에 붙어 변하지 않도록 하는 역할을 수행합니다. 의도치 않은 변경을 줄여 코드 안정성을 보장하고 final 변수는 상수이기 때문에 컴파일 과정에서 성능 향상을 가져올 수 있습니다. 또한, 코드 가독성을 높일 수 있습니다.
### 정리

#### 코드 안정성
- 의도치 않은 코드 변경을 줄일 수 있기 때문에 코드 안정성이 높아진다.
#### 성능 향상
- final 변수는 상수로 취급하여 컴파일 과정에서 변수를 계산하는 과정이 준다. 이만큼 성능 향상을 불러올 수 있다.
#### 코드 가독성
- 변수, 메서드, 클래스에 final 키워드를 붙이면 변경되지 않는다는 의미를 명확하게 전달할 수 있다.
### 참고 링크
</details>

<details>
    <summary><b>final, finally, finalize 에 대해 설명해주세요</b></summary> 

### 답변

- final 키워드는 변수, 메서드, 클래스를 변경 불가능하도록 만드는 것이고, finally 는 try-catch 구문 마지막에 항상 실행될 코드 블록을 정의하기 위해 사용됩니다. 마지막으로 finalize 는 GC 가 더이상의 참조가 존재하지 않는 객체를 메모리에서 삭제할 때 사용되는 메서드입니다.
### 정리

#### final
- 기본 데이터 타입에 적용: 변수에 저장된 값의 변경이 불가능
- 참조 데이터 타입에 적용: 참조 변수의 힙 메모리를 재할당 불가능
- 메서드에 적용: 오버라이드 불가능
- 클래스에 적용: 상속 불가능
#### finally
- try-catch 구문이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용
- JVM 이 종료되거나 해당 프로세스가 종료되지 않는 이상 무조건 실행된다.
  - return 문이 try 에 있어도 finally 코드 블록이 실행됨
  - try-with-resources 구문을 사용할 수 있으면 try-catch-finally 대신 사용할 것
    - 예외가 중복될 경우 디버깅이 힘듦
    - 가독성이 나빠짐
#### finalize
- Garbage Collector 가 더이상 참조가 존재하지 않는 객체를 메모리에서 삭제할 때 호출하는 메서드
- Object 클래스의 finalize 메서드를 오버라이딩하여 커스텀할 수 있다.
### 참고 링크

- https://wjheo.tistory.com/entry/final-finally-finalize-%EC%B0%A8%EC%9D%B4%EC%A0%90
- https://ckddn9496.tistory.com/62
</details>


<details>
    <summary><b>final 키워드는 컴파일 과정에서 다르게 실행될까요?</b></summary> 

### 답변

- final 키워드가 붙은 변수는 상수와 같이 취급이 됩니다. 메서드는 오버라이딩이 안되기 때문에 오버라이딩한 메서드를 찾는 과정이 생략됩니다. 클래스는 상속이 불가능하기 때문에 자식 클래스를 찾는 과정이 생략됩니다.
### 참고 링크

</details>


---

<details>
    <summary><b>제네릭에 대해 설명해주세요.</b></summary> 

### 답변

- 제네릭은 클래스 내부에서 사용하는 타입을 외부에서 지정할 수 있는 방법입니다. 장점으로는 컴파일 시점에 타입 체크를 진행해 타입 안정성을 보장하고 코드 중복을 줄여줍니다. 반면 단점으로는  문법이 생소하여 가독성이 떨어지고 공변성 때문에 배열과의 호환성이 좋지 않습니다.
### 정리

- 클래스 내부에서 사용하는 타입을 외부에서 지정하는 방법
- 장점
  - 컴파일 시점에 타입 체크를 통해 타입 안정성을 보장
  - 코드 중복을 줄여줌
- 단점
  - 문법이 생소하여 가독성이 떨어짐.
  - 배열의 공변성으로 인해 배열과의 호환성이 떨어짐

#### 무변성(invariant)/무공변
- 하위 타입을 상위 타입의 제네릭에 대입하면 컴파일 에러가 발생한다.
```java
public class Tiger extends Animal {}
```

```java
public class Cage<T> {
	private List<T> animals = ...;
	public void push(T animal) {
		this.animals.add(animal);
    }
	public List<T> getAll() {
		return animals;
    }
}
```

```java
Animal a = new Tiger(); // OK
Cage<Animal> ca = new Cage<Tiger>(); // Compile Error.
```

<br>

- 컴파일 에러가 발생하는 이유를 예를 들어 설명하면
```java
public class Tiger extends Animal {}
public class Lion extends Animal {}
```
```java
Cage<Tiger> ct = new Cage<Tiger>();
Cage<Animal> ca = ct; // 만약 가능하다면

ca.push(new Lion()); // Lion 은 Animal 의 하위 타입이므로 가능

List<Tiger> tigers = ct.getAll(); // 우항의 결과물은 List<Lion> 
```

<br>

- 무공변일 때 문제점
```java
public class Carnivore extends Animal {}
public class Tiger extends Carnivore {}
public class Lion extends Carnivore {}
```
```java
public class Zookeeper {
	public void giveMeat(Cage<Carnivore> cage, Meat m) {
		
    }
}
```
```java
Zookeeper zk = new Zookeeper();
Cage<Tiger> ct = new Cage<>();
zk.giveMeat(ct,m); // Compile Error
```
- 위의 코드를 보면 Cage<Carnivore> 은 Cage<Tiger> 의 상위 타입이 아니기 때문에 에러가 발생한다.
- 공변으로 해결이 가능!

#### 공변(variant)

- 타입 A 가 타입 B 의 상위 타입이고, `T<A>` 가 `T<B>` 의 상위 타입일 때 공변이라고 한다.
- extends 를 이용하여 나타냄
```java
public class Zookeeper {
	public void giveMeat(Cage<? extends Carnivore> cage, Meat m) {
		
    }
}
```
```java
Zookeeper zk = new Zookeeper();
Cage<Tiger> ct = new Cage<>();
zk.giveMeat(ct,m); // 할당 가능

Cage<Lion> cl = new Cage<>();
zk.giveMeat(cl,m); // 할당 가능
```

<br>

- 공변에서의 문제점
  - 공변에서 제네릭 타입을 사용하면 메서드에 값 전달이 되지 않는다.
```java
Cage<Tiger> ct = new Cage<>();

Cage<? extends Carnivore> cage = ct; // OK
cage.push(new Tiger()); // Compile Error
```
- 위의 경우 cage 의 실제 타입이 `Cage<Tiger>` 인지 `Cage<Lion>` 인지 알수 없기 때문에 컴파일 에러 발생
- 반공변으로 해결!

#### 반공변(contravariant)
- A 가 B 의 상위 타입이고, `T<A>` 가 `T<B>` 의 하위 타입이면 반공변
  - super 을 사용하여 나타냄
```java
Cage<Tiger> ct = new Cage<>();

Cage<? super Tiger> ctt = ct; // OK
ctt.push(new Tiger()); // OK, ctt 는 Cage<Tiger> 이거나 상위타입

Cage<Carnivore> cc = new Cage<>();
Cage<? super Tiger> ctt2 = cc; // OK
ctt2.push(new Tiger()); // OK, ctt2 는 Cage<Tiger> 이거나 상위 타입
```

### 참고 링크

- https://www.youtube.com/watch?v=PtM44sO-A6g
</details>


---

<details>
    <summary><b>리플렉션이 무엇이고, 언제 활용 가능한지 설명해주세요.</b></summary> 

### 답변

- 리플렉션은 동적으로 클래스의 정보를 얻어 사용할 수 있는 기법입니다. 주로 런타임에 클래스에 접근하여 정보를 얻어야 할 때 사용됩니다. 예시로는 Spring 의 애노테이션, Jackson 등이 있습니다.
### 정리

- 런타임에 클래스의 이름, 메서드, 필드 등을 동적으로 가져오는 API
- 클래스 정보가 런타임 시점에 필요할 때 이용
- Spring 의 애노테이션, IDE 의 자동완성, Jackson 등이 있다.
### 참고 링크

- https://velog.io/@alsgus92/Java-Reflection%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%96%B8%EC%A0%9C%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C
</details>


<details>
    <summary><b>리플렉션의 장단점에 대해 설명해주세요.</b></summary> 

### 답변

- 리플렉션의 장점으로는 클래스의 정보를 동적으로 로딩할 수 있다는 장점이 있습니다. 또한 객체를 런타임에 생성하여 유연성을 높일 수 있습니다. 반면 단점으로는 private 메서드에 접근할 수 있는 보안문제와 타입이 정해지지 않는 클래스의 정보를 동적으로 가져오기 때문에 성능 저하가 있습니다.
### 정리

#### 장점

- 클래스의 정보를 동적으로 로딩
- 객체를 런타임에 생성

#### 단점

- 타입이 정해지지 않는 클래스의 정보를 가져오기 때문에 컴파일러의 최적화를 받지 못한다. 이 때문에 성능 저하가 발생한다.
- 동적으로 클래스 정보를 가져오기 때문에 가독성이 떨어진다.
- private 메서드에 접근할 수 있기 때문에 보안문제가 생긴다.
### 참고 링크

- https://middleearth.tistory.com/72
</details>


---

<details>
    <summary><b>자바의 직렬화와 역직렬화에 대해 설명해주세요.</b></summary> 
</details>

---

<details>
    <summary><b>자바의 Synchronized 키워드를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동기화와 비동기화의 차이를 설명해주세요.</b></summary> 
</details>

<details>
    <summary><b>동시성 문제가 무엇인가요? 자바에서 동시성 문제를 해결할 수 있는 방법이 있을까요?</b></summary> 
</details>

---

<details>
    <summary><b>자바의 어노테이션에 대해 설명해주세요.</b></summary> 
</details>

