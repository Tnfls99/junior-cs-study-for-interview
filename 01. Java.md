<details>
  <summary><b>Java 의 장단점에 대해 설명해주세요.</b></summary>

### 답변

장점으로는 JVM에서 동작하기 때문에 운영체제에 독립적이고 객체지향 언어이기 때문에 이해하기가 쉽습니다. 또한 가비지 컬렉터에 의해 메모리를 자동으로 관리해준다는 점이 있습니다.
단점으로는 JVM 에 의해 번역되는 과정이 필요하기 때문에 비교적 느립니다. 또한 가비지 컬렉터로 인하여 비교적 많은 메모리 공간이 필요합니다.

### 정리

- 장점
    - JVM에서 동작하기 때문에 운영체제에 독립적
    - 객체지향 언어이기 때문에 이해하기 쉽다.
    - 오픈소스로 사용할 수 있고 커뮤니티가 잘 발달되어 있다.
    - 멀티쓰레드를 쉽게 구현할 수 있다.
    - 가비지 컬렉터에 의해 메모리 관리를 자동으로 해준다.
- 단점
    - 컴파일되고 번역하는 과정을 거치기 때문에 비교적 느리다.
    - 가비지 컬렉터로 인해 메모리 공간 필요

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java-%EC%96%B8%EC%96%B4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90
- https://data-flair.training/blogs/pros-and-cons-of-java/

</details>

---

<details>
  <summary><b>Java 의 데이터 타입에 대해 설명해주세요.</b></summary>

### 답변

자바의 데이터 타입은 기본 데이터 타입과 참조 타입으로 나뉩니다. 기본 데이터 타입으로는 byte, short, int, long, float, double, boolean, char 가 있으며 Stack 영역에
저장됩니다. 참조 타입은 기본형은 제외한 모든 타입이며, Heap 영역에 저장됩니다.

### 정리

- 기본 데이터 타입(Primitive Data Type)
    - 정수형 : byte, short, int, long
    - 실수형 : float, double
    - 논리형 : boolean(ture/false)
    - 문자형 : char
    - 기본 타입의 크기가 작고 고정적이기 때문에 메모리의 Stack 영역에 저장된다.
- 참조 타입(Reference Data Type)
    - 참조 타입 종류: class, array, interface, Enumeration
    - 기본형을 제외하고는 모두 참조형
    - new 키워드를 이용하여 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입이다.
    - String과 배열은 참조 타입과 달리 new 없이 생성이 가능하지만 기본 타입이 아닌 참조 타입이다.
    - 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
    - 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
    - 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85

</details>

<details>
  <summary><b>Wrapper 클래스와 Boxing, Unboxing 에 대해서 설명해주세요.</b></summary>

### 답변

Wrapper 클래스는 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스입니다. 기본 타입의 데이터를 Wrapper 클래스의 값으로 변환하면 Boxing,
반대의 경우를 Unboxing이라고 합니다.

### 정리

- Wrapper Class
    - 프로그램에 따라 기본 데이터 타입을 객체로 취급해야 하는 경우, 기본 타입들의 데이터를 객체로 포장한 클래스
    - java.lang 패키지에 존재

| 기본 타입     | 래퍼 클래스      |
|-----------|-------------|
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `char`    | `Character` |
| `boolean` | `Boolean`   |

- Boxing
    - 기본 타입의 데이터를 Wapper 클래스의 인스턴스로 변환하는 과정
- Unboxing
    - Wrapper 클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 꺼내는 과정

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#wrapper-class

</details>


---

<details>
  <summary><b>Java는 Call by Value인가요 Call by Reference인가요?</b></summary> 

### 답변

자바는 Call by Value 를 따릅니다. 기본 자료형의 경우 해당 값이 복사되어 전달되고, 참조 자료형의 경우 힙 메모리의 참조값이 복사되어 전달됩니다.

### 정리

- 자바에서 파라미터는 항상 `값`으로 전달됩니다. (파라미터의 복사본이 메서드에 전달)
- 기본 자료형의 경우 값의 복사본이 전달됩니다.
- 참조 자료형의 경우 힙 메모리의 주소값이 복사되어 전달됩니다.
    - 아래 예시의 경우 User 의 메모리가 복사되어 전달된다. b 의 경우 새로운 주소를 할당하는데 메서드가 종료되면 원본 b 에는 반영되지 않는다.
  ```java
  class User {
      public int age;
  
      public User(int age) {
          this.age = age;
      }
  }
  
  public class ReferenceTypeTest {
  
      void test() {
          User a = new User(10);
          User b = new User(20);
  			  
          System.out.println(a); // age: 10
          System.out.println(b); // age: 20
          modify(a, b);
  
          System.out.println(a); // age: 11 
          System.out.println(b); // age: 20
      }
  
      private void modify(User a, User b) {
          a.age++;
  
          b = new User(30);
          b.age++;
      }
  }
  ```

### 참고 링크

- https://bcp0109.tistory.com/360
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#call-by-reference%EC%99%80-call-by-value%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>Java 의 접근제어자는 어떤 것이 있나요?</b></summary> 

### 답변

자바의 접근 제어자로는 제약 없이 접근 가능한 public, 동일 패키지 또는 상속 관계에서 접근 가능한 protected, 동일 패키지에서만 접근 가능한 package-private, 선언한 객체에서만 사용 가능한
private 이 있습니다.

### 정리

| 접근 제어자	           | 설명                             |
|-------------------|--------------------------------|
| `public`          | `해당 객체를 사용하는 프로그램 어디에서나 접근 가능` |
| `protect`         | `동일 패키지 또는 상속 관계의 객체에서 접근 가능`  |
| `package-private` | `동일 패키지에서 접근 가능`               |
| `private`         | `해당 객체에서만 사용 가능`               |

### 참고 링크

- http://www.tcpschool.com/java/java_modifier_accessModifier
- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#java%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95

</details>

---

<details>
  <summary><b>클래스, 객체, 인스턴스를 비교해주세요.</b></summary> 

### 답변

클래스는 객체를 만들어 내기 위한 틀로서 객체가 가질 수 있는 속성과 메서드를 정의하며, 이를 실체화한 것이 객체입니다. 인스턴스는 객체의 구체적인 사례입니다.

### 정리

- 클래스(Class)
    - 객체를 만들어 내기 위한 설계도 혹은 틀
    - 연관되어 있는 변수와 메서드의 집합
- 객체(Object)
    - 소프트웨어 세계에 구현할 대상
    - 클래스에 선언된 모양 그대로 생성된 실체
    - '클래스의 인스턴스(instance)' 라고도 부른다.
    - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
    - oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.
- 인스턴스(Instance)
    - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
        - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
        - 실체화된 인스턴스는 메모리에 할당된다.
    - 인스턴스는 객체에 포함된다고 볼 수 있다.
    - oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
    - 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계 에 초점을 맞출 경우에 사용한다.
        - '~의 인스턴스' 의 형태로 사용된다.
        - 객체는 클래스의 인스턴스다.
        - 객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
    - 실행 프로세스는 프로그램의 인스턴스다.
    - 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
    - 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다.

### 참고 링크

- https://github.com/WeareSoft/tech-interview/blob/master/contents/java.md#%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4

</details>

---

<details>
  <summary><b>static 키워드에 대해 설명해주세요.</b></summary> 

### 답변

클래스 멤버를 정의할 때 사용되며, 객체가 생성되기 전에 초기화 되며, 모든 인스턴스에서 공유되어 사용됩니다.

### 정리

- 클래스 멤버를 정의할 때 사용
- 객체가 생성되기 전에 클래스의 로딩 과정에서 메모리에 할당되므로, 객체 생성 없이 클래스 이름만으로 접근할 수 있다.
- static 키워드를 적절히 사용하면, 메모리를 효율적으로 사용하거나 객체 생성 없이도 편리하게 접근할 수 있는 장점이 있다.

<details> <summary>클래스 멤버와 인스턴스 멤버</summary>
- 클래스 멤버: 클래스에 존재하는 변수와 메서드.
- 인스턴스 멤버: 객체(인스턴스)에 존재하는 변수와 메서드. static 키워드를 사용하지 않고 정의한다.
- 클래스 멤버에서는 인스턴스 멤버가 접근 가능하지만, 인스턴스 멤버에서는 클래스 멤버로 접근이 불가능하다.
  ![](../../../../../var/folders/1q/jkln67w958d9zskbyx2v6p940000gn/T/TemporaryItems/NSIRD_screencaptureui_x5cM7o/스크린샷 2023-03-31 오전 3.08.16.png)
</details>

### 참고 링크

- [클래스 멤버와 인스턴스 멤버](https://hyuntaekhong.github.io/blog/java-basic12/)

</details>

<details>
  <summary><b>static 멤버와 non-static 멤버는 무슨 차이가 있나요?</b></summary> 

### 답변

- static 멤버는 클래스가 로딩될 때 메모리에 할당되며, 모든 인스턴스에서 공유됩니다. 반면에 non-static 멤버는 각 인스턴스가 생성될 때 메모리에 할당되고, 인스턴스마다 고유한 값을 가집니다.

### 정리

- 다음과 3가지의 차이점이 존재한다.

| 항목           | 메모리 할당 시기   | 접근 방법                     | 공유 여부             |
|--------------|-------------|---------------------------|-------------------|
| `static`     | 클래스가 로딩될 때  | 인스턴스를 생성하지 않고 클래스 이름으로 접근 | 모든 인스턴스가 동일한 값 공유 |
| `non-static` | 인스턴스가 생성될 때 | 인스턴스를 생성한 후 접근            | 인스턴스마다 고유한 값 존재   |

### 참고 링크

</details>

<details>
  <summary><b>main 메서드는 왜 static 메서드인가요?</b></summary> 

### 답변

- main 메서드는 프로그램이 실행될 때 가장 먼저 호출됩니다. 인스턴스가 생성되기 전에 호출되어야 하기 때문에 static으로 정의되어야 합니다.

### 정리

- main 메서드는 프로그램이 시작할 때 JVM에 의해 호출됩니다. 만약 non-static 메서드라면, main 메서드를 호출하기위해 클래스를 인스턴스화 시켜야 하기 때문에 JVM 에서 직접 호출이 불가능합니다.
  따라서 main 메서드는 static 메서드여야 합니다.

### 참고 링크

- https://www.scaler.com/topics/why-main-method-is-static-in-java/

</details>

<details>
  <summary><b>자바 프로그램 실행 시 static 이 붙은 변수는 어떻게 처리되나요?</b></summary>

### 답변

- static 이 붙은 변수는 해당 클래스가 로딩될 때 Method Area에 한번 초기화되고 값 변경이 일어나지 않습니다. 이후에 인스턴스를 초기화하지 않고 사용할 수 있습니다.

### 정리

- 자바 프로그램이 실행되고 JVM이 프로그램에서 사용되는 클래스를 로드하고, 해당 static 변수를 초기화합니다.
- JVM은 Method Area 에 static 변수에 메모리를 할당합니다.

### 참고 링크

</details>

---

<details>
  <summary><b>오버로딩과 오버라이딩을 비교해주세요.</b></summary> 

### 답변

- 오버로딩은 메서드의 이름은 같고 파라미터를 다르게 한 것이고, 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것을 의미합니다.

### 정리

- 오버로딩
    - 이름은 같고 매개변수의 수, 타입 또는 순서가 다른 여러 메서드 정의
    - 반환하는 타입은 달라도 된다.
- 오버라이딩
    - 메서드 이름과 매개변수가 동일한 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것
    - 오버라이딩된 메서드가 자식클래스의 인스턴스에서 호출되면 부모 클래스의 메서드는 무시된다.

### 참고 링크

- https://hyoje420.tistory.com/14

</details>

---

<details>
  <summary><b>인터페이스와 추상클래스를 비교해주세요.</b></summary> 

### 답변

### 정리

### 참고 링크

</details>

---

<details>
  <summary><b>Java의 Error, Exception 구조에 대해 설명해주세요.</b></summary> 

### 답변

### 정리

### 참고 링크

</details>

<details>
  <summary><b>CheckedException 과 UncheckedException 은 무슨 차이인가요?</b></summary> 

### 답변

### 정리

### 참고 링크

</details>


